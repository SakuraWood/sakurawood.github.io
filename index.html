<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>SakuraWood&#39;s blogs | Welcome to my personal site!硕硕的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Android Front-end">
    <meta name="description" content="sharing IT tech &amp; skills , include Android and Front-end">
<meta name="keywords" content="Android Front-end">
<meta property="og:type" content="website">
<meta property="og:title" content="SakuraWood&#39;s blogs">
<meta property="og:url" content="http://sakurawood.github.io/index.html">
<meta property="og:site_name" content="SakuraWood&#39;s blogs">
<meta property="og:description" content="sharing IT tech &amp; skills , include Android and Front-end">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SakuraWood&#39;s blogs">
<meta name="twitter:description" content="sharing IT tech &amp; skills , include Android and Front-end">
    
        <link rel="alternate" type="application/atom+xml" title="SakuraWood&#39;s blogs" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/sakurawood.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">SakuraWood(Lee Sure)</h5>
          <a href="mailto:smartadelesure@gmail.com" title="smartadelesure@gmail.com" class="mail">smartadelesure@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect active">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/SakuraWood" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-link"></i>
                About
              </a>
            </li>
        
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=240 height=86 src="//music.163.com/outchain/player?type=2&id=446512123&auto=1&height=66"></iframe>
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">SakuraWood&#39;s blogs</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header index-header">

    <div class="container fade-scale">
        <h1 class="title">SakuraWood&#39;s blogs</h1>
        <h5 class="subtitle">
            
                Welcome to my personal site!硕硕的博客
            
        </h5>
    </div>

    


</header>

<div class="container body-wrap">

    <ul class="post-list">
    
        <li class="post-list-item fade">
            <article id="post-形式语言与自动机"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2017-11-15 15:54:07" datetime="2017-11-15T07:54:07.000Z"  itemprop="datePublished">2017-11-15</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/计算机科学/">计算机科学</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2017/11/15/形式语言与自动机/">形式语言与自动机</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    <!-- 
        形式语言与自动机
未来一定属于语言的胜利。语言将一统天下（未来AI也会用“最优”的语言来思考）。

一直好奇的是，远古巨神们是怎么发明出计算机的？计算机也肯定是遵循某些理论发展出来的。
阿兰·图灵和冯·诺依曼是公认的两位计算机之父。图灵机从理论上证明了计算机这种东西可行，而冯诺依曼结构则从物理上实现了图灵机的理论。即使到现在，几乎所有计算模型和结构也没能脱离这两者而存在。

什么是形式语言与...
     -->

    <h1 id="形式语言与自动机"><a href="#形式语言与自动机" class="headerlink" title="形式语言与自动机"></a>形式语言与自动机</h1><ul>
<li>未来一定属于语言的胜利。语言将一统天下（未来AI也会用“最优”的语言来思考）。</li>
</ul>
<p>一直好奇的是，远古巨神们是怎么发明出计算机的？计算机也肯定是遵循某些理论发展出来的。</p>
<p>阿兰·图灵和冯·诺依曼是公认的两位计算机之父。图灵机从理论上证明了计算机这种东西可行，而冯诺依曼结构则从物理上实现了图灵机的理论。即使到现在，几乎所有计算模型和结构也没能脱离这两者而存在。</p>
<ul>
<li>什么是形式语言与自动机？</li>
</ul>
<p>计算机科学有两个主要的部分: 第一, 构成计算系统基础的一些基本概念和模型; 第二, 设计计算系统 (软件和硬件) 的工程技术。形式语言与自动机理论, 就是作为第一部分, 即构成计算基础的基本概念的引论。</p>
<ul>
<li>目的是什么？</li>
</ul>
<p>学会像前人一样思考，打开通往组成原理和操作系统的两扇大门。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li>基本概念</li>
</ul>
<ol>
<li><p>字母表</p>
<p> 众所周知，字母是构成一门语言的基本要素哦，如英文中的A-Z（a-z）。对于计算机而言，其实是{0,1}。</p>
<p> 定义：有穷非空符号集。例如, Σ = {0, 1}, Σ = {a, b …  z}。</p>
</li>
<li><p>字符串</p>
<p> 某个字母表中符号的有穷序列, 也称字 (words). 例如, 若 Σ = {0, 1}, 则000, 111, 0101,10101 为 Σ 上的字符串.</p>
</li>
</ol>

        <a href="/2017/11/15/形式语言与自动机/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动机/">自动机</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-gradle学习笔记"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2017-08-15 15:54:07" datetime="2017-08-15T07:54:07.000Z"  itemprop="datePublished">2017-08-15</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android开发/">Android开发</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2017/08/15/gradle学习笔记/">gradle 学习笔记</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    <!-- 
        gradle上路篇作为写Android的人（虽然现在重心已经偏向js），当遇上gradle编译时各种各样的错误，，你却不知道怎么办，有时虽然解决了却不知道所以然，我想这样的经历绝不只有我一个。
如果说为什么对gradle始终很糊涂，那么Android Studio将要背很大的锅，因为IDE为你生成好了构建脚本，所以你无需花很多精力去了解它，你的任务更多只是在业务代码本身，事实上，学习grad...
     -->

    <h1 id="gradle上路篇"><a href="#gradle上路篇" class="headerlink" title="gradle上路篇"></a>gradle上路篇</h1><p>作为写<code>Android</code>的人（虽然现在重心已经偏向<code>js</code>），当遇上<code>gradle</code>编译时各种各样的错误，，你却不知道怎么办，有时虽然解决了却不知道所以然，我想这样的经历绝不只有我一个。</p>
<p>如果说为什么对<code>gradle</code>始终很糊涂，那么<code>Android Studio</code>将要背很大的锅，因为<code>IDE</code>为你生成好了构建脚本，所以你无需花很多精力去了解它，你的任务更多只是在业务代码本身，事实上，学习gradle你还可以更加地了解<code>android</code>程序整个构建过程，在这一点上，恐怕很多人也跟当初我一样是一知半解的。</p>
<h2 id="为什么是build-gradle"><a href="#为什么是build-gradle" class="headerlink" title="为什么是build.gradle?"></a>为什么是build.gradle?</h2><p>对呀，为什么是这个文件？其实它没有什么特别的，只不过因为它是默认的构建脚本。所以好事者说，我想执行自己的怎么办？比如<code>a.gradle</code>？ 好，那么其实你可以执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gradle -b a.gradle yourtask</div></pre></td></tr></table></figure></p>
<p>这样子你可以将构建脚本替换成你想执行的<code>a.gradle</code>。可能对于一直点击<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/run.png" alt="run](/images/run.png)图标的同学来说，`gradle`命令行甚至都没用过，这个`yourtask`是什么鬼？其实在你点击了![run" title="">
                </div>
                <div class="image-caption">run](/images/run.png)图标的同学来说，`gradle`命令行甚至都没用过，这个`yourtask`是什么鬼？其实在你点击了![run</div>
            </figure>图标之后，<code>gradle</code>的构建脚本可是做了大量的工作，之后我会细说。</p>
<h2 id="Groovy语言"><a href="#Groovy语言" class="headerlink" title="Groovy语言"></a>Groovy语言</h2><p><code>gradle</code>脚本其实是基于一个叫<code>Groovy</code>的语言编写的，它的语法相当友好，兼容<code>java</code>语法，有着一些<code>java</code>语言并没有的特性，比如函数传参。但事实上，你并不需要过多了解这门语言，对于<code>gradle</code>脚本来说，掌握部分就够用了。</p>
<p>我并不想在这里介绍<code>Groovy</code>语言，有闲时间我建议直接看<code>Groovy</code>的官方指南：</p>
<p><a href="http://groovy-lang.org/documentation.html" target="_blank" rel="external">http://groovy-lang.org/documentation.html</a></p>
<h2 id="项目示例"><a href="#项目示例" class="headerlink" title="项目示例"></a>项目示例</h2><p>有些人不想看也不想了解<code>Groovy</code>语言，那也没事，我直接拿个例子，看完你就想去看了，拿个android工程的构建脚本，先来最简单的，用<code>Android Studio</code>创建完一个新的<code>android</code>工程之后，<code>IDE</code>给你准备了大致上这样的东西：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/android_new_project.png" alt="project" title="">
                </div>
                <div class="image-caption">project</div>
            </figure></p>
<p>刚才不是说<code>build.gradle</code>是默认的吗，怎么两个啊？所以，很多人在开发时会切到真实的目录下去，像这样的：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/real_project.png" alt="project" title="">
                </div>
                <div class="image-caption">project</div>
            </figure></p>
<p>来看看项目根目录下的<code>build.gradle</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// Top-level build file where you can add configuration options common to all sub-projects/modules.</div><div class="line"></div><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:2.2.3&apos;</div><div class="line"></div><div class="line">        // NOTE: Do not place your application dependencies here; they belong</div><div class="line">        // in the individual module build.gradle files</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">task clean(type: Delete) &#123;</div><div class="line">    delete rootProject.buildDir</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个<code>gradle</code>构建脚本看上去具有拆分式<code>JSON</code>语法，先看最下面，这里定义了一个<code>task</code>，叫做<code>clean</code>，<code>task</code>是<code>gradle</code>内置的定义任务的关键字，不用我说你也知道<code>clean</code>这是干嘛用的，当你点击<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/clean_project.png" alt="project" title="">
                </div>
                <div class="image-caption">project</div>
            </figure>这个的时候，它就在执行这个任务。</p>
<p>另外这个，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:2.2.3&apos;</div><div class="line"></div><div class="line">        // NOTE: Do not place your application dependencies here; they belong</div><div class="line">        // in the individual module build.gradle files</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><code>dependencies</code>表示的是项目依赖，而这里定义了所引用的<code>gradle</code>插件， 好吧，这个<code>&#39;com.android.tools.build:gradle:2.2.3&#39;</code>它来自哪？当然是从项目存储库里取，<code>repositories{}</code>定义了依赖的源链接库。</p>
<p>注意，<code>gradle</code>并不是专门为<code>android</code>而生，根目录下的<code>build.gradle</code>使用的可是<code>gradle</code>自带的<code>Build script blocks</code>,<br>像<code>allprojects{}</code>,<code>repositories{}</code>,<code>dependencies{}</code>等等（wtf? 请参阅<a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">https://docs.gradle.org/current/dsl/</a>）。</p>
<p>好了，我们再继续看看<code>app</code>目录下的<code>build.gradle</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.android.application&apos;</div><div class="line"></div><div class="line">android &#123;</div><div class="line">    compileSdkVersion 25</div><div class="line">    buildToolsVersion &quot;25.0.2&quot;</div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId &quot;com.example.administrator.myapplication&quot;</div><div class="line">        minSdkVersion 15</div><div class="line">        targetSdkVersion 25</div><div class="line">        versionCode 1</div><div class="line">        versionName &quot;1.0&quot;</div><div class="line">    &#125;</div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            minifyEnabled false</div><div class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</div><div class="line">    androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123;</div><div class="line">        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;</div><div class="line">    &#125;)</div><div class="line">    compile &apos;com.android.support:appcompat-v7:25.1.0&apos;</div><div class="line">    testCompile &apos;junit:junit:4.12&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一行说明你引用了一个<code>gradle</code>插件<code>com.android.application</code>,就好比你在写<code>java</code>代码时所引用的包一样，那这个包在哪取？就是之前根目录下的<code>build.gradle</code>所定义的<code>com.android.tools.build:gradle:2.2.3</code>插件。</p>
<p>既然引用了插件，当然就可以开始用插件里的东西了，所以<code>android{}</code>标签来了，注意只有<code>compileSdkVersion</code>跟<code>buildToolsVersion</code>是必须的，除此之外你可以定义一切不超出插件语法范围的配置。进一步的<code>android gradle</code>插件配置，可以参考<a href="http://tools.android.youdaxue.com/tech-docs/new-build-system/user-guide" target="_blank" rel="external">http://tools.android.youdaxue.com/tech-docs/new-build-system/user-guide</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">        applicationId &quot;com.example.administrator.myapplication&quot;         //app的id</div><div class="line">        minSdkVersion 15                                                //最低sdk版本号</div><div class="line">        targetSdkVersion 25                                             //目标sdk版本号</div><div class="line">        versionCode 1                                                   //应用版本号</div><div class="line">        versionName &quot;1.0&quot;                                               //应用版本名</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>你会发现<code>defaultConfig{}</code>里面定义的其实都是可以在<code>manifest.xml</code>中可以定义的。</p>
<p><code>buildTypes</code>代表构建类型，用于控制构建和包装应用的方式。<code>android</code>工程默认有两个构建类型，一个是<code>release</code>,一个是<code>debug</code>。有些人跃跃欲试了，这是不是就是多渠道打包了啊？嗯，有点接近，但并不是。插件额外定义了另外一个<code>block</code>，用以构建面向用户的版本，这就是<code>productFlavors</code>(产品风格)。</p>
<p>假如发布应用，一个收费版和一个免费版的，则可以这样定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">     free &#123;</div><div class="line">         applicationId &quot;com.example.administrator.myapplication.free&quot;</div><div class="line">     &#125;</div><div class="line">     paid &#123;</div><div class="line">         applicationId &quot;com.example.administrator.myapplication.paid&quot;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>你也看到了，其实所有可以放进<code>defaultConfig{}</code>里的东西，都可以放到<code>productFlavors</code>中，如有重复项则会覆盖掉默认配置。</p>

        <a href="/2017/08/15/gradle学习笔记/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gradle/">gradle</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-css盒模型"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2017-08-15 15:54:07" datetime="2017-08-15T07:54:07.000Z"  itemprop="datePublished">2017-08-15</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端/">前端</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2017/08/15/css盒模型/">css 盒模型</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    <!-- 
        如果你之前接触过开发，有着UI编写经验，这也许是最容易理解的教程。就算之前没接触过开发，也能迅速理解css的盒模型原理。
编写界面，无非是把你想放的元素放到该放的位置上去。
css中的一个基本概念是盒模型，可见元素会在页面中占据一个矩形区域，该区域就是元素的盒子(box)。

     -->

    <p>如果你之前接触过开发，有着UI编写经验，这也许是最容易理解的教程。就算之前没接触过开发，也能迅速理解css的盒模型原理。</p>
<p><code>编写界面，无非是把你想放的元素放到该放的位置上去。</code></p>
<p>css中的一个基本概念是盒模型，可见元素会在页面中占据一个矩形区域，该区域就是元素的盒子(box)。</p>

        <a href="/2017/08/15/css盒模型/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-一道位操作题引发的思考"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2017-07-12 15:54:07" datetime="2017-07-12T07:54:07.000Z"  itemprop="datePublished">2017-07-12</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/算法/">算法</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2017/07/12/一道位操作题引发的思考/">一道位操作题引发的思考</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    <!-- 
        给定整数数组，每个元素出现三次，除了一个出现恰好一次。找到那个单一的。
这道题如果换成“给定整数数组，每个元素出现两次，除了一个出现恰好一次。找到那个单一的。”会简单很多，因为利用异或操作符，可以把两个相同的元素消掉。比如：a^a=0。
但是现在问题是出现了三次,先放上代码：
1234567def singleNumber(A):    ones = 0    twos = 0    for...
     -->

    <p>给定整数数组，每个元素出现三次，除了一个出现恰好一次。找到那个单一的。</p>
<p>这道题如果换成“给定整数数组，每个元素出现两次，除了一个出现恰好一次。找到那个单一的。”会简单很多，因为利用异或操作符，可以把两个相同的元素消掉。比如：a^a=0。</p>
<p>但是现在问题是出现了三次,先放上代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(A)</span>:</span></div><div class="line">    ones = <span class="number">0</span></div><div class="line">    twos = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> A:</div><div class="line">        ones = (ones ^ i) &amp; ~twos</div><div class="line">        twos = (twos ^ i) &amp; ~ones</div><div class="line">    <span class="keyword">return</span> ones</div></pre></td></tr></table></figure>
<p>这代码一看就懵逼。而且对于不熟悉位操作的人，简直就是痛苦。WTF？<br>这段代码看上去很诡异，但其实它是有来头的。</p>
<p>就像异或操作那样，我们把两个相同的元素消掉为0，那为何不想想如何把3个给消掉呢？很遗憾，计算机没有提供这样的操作符。但是你可以自定义。</p>
<p>如何做呢？我们需要一个像计数器一样的东西，这个东西能记住每一位上1所出现的次数。例如本道题，可以认为出现3次就归零。这个计数器也用位来表示，那么它的状态变化就是00-&gt;01-&gt;10-&gt;00。</p>
<p>比如一个数组[3,3,3,1],不用想，它的结果为1。在这里我描述一下过程。</p>
<p>首先来了个3，计数器，一开始肯定是00，3用二进制表示就是11，那么它</p>

        <a href="/2017/07/12/一道位操作题引发的思考/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-位操作"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2017-07-07 15:54:07" datetime="2017-07-07T07:54:07.000Z"  itemprop="datePublished">2017-07-07</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/算法/">算法</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2017/07/07/位操作/">位操作</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    <!-- 
        位操作一道典型的面试题：
给定一个数组，它里面的元素都出现过两次，除了有一个元素，请找出这个元素。
暴力点的，估计就双重循环解决了。。。
但事实上，有一个时间复杂度为O(n)的方法。那就是位操作。
平时码业务逻辑的代码多了，都忘了位操作究竟是啥。

                
                    
                    
             ...
     -->

    <h1 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h1><p>一道典型的面试题：</p>
<p>给定一个数组，它里面的元素都出现过两次，除了有一个元素，请找出这个元素。</p>
<p>暴力点的，估计就双重循环解决了。。。</p>
<p>但事实上，有一个时间复杂度为O(n)的方法。那就是位操作。</p>
<p>平时码业务逻辑的代码多了，都忘了位操作究竟是啥。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/bit_ma.png" alt="bst" title="">
                </div>
                <div class="image-caption">bst</div>
            </figure>
        <a href="/2017/07/07/位操作/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-gulp构建工具"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2017-06-27 15:54:07" datetime="2017-06-27T07:54:07.000Z"  itemprop="datePublished">2017-06-27</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端/">前端</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2017/06/27/gulp构建工具/">Gulp构建工具</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    <!-- 
        Gulp构建工具gulp与webpack
gulp是工具链、构建工具，可以配合各种插件做js压缩，css压缩，sass编译 替代手工实现自动化工作
webpack是文件打包工具，可以把项目的各种js文、css文件等打包合并成一个或多个文件，主要用于模块化方案，预编译模块的方案

其实webpack很多功能gulp都能做，gulp甚至能够配置webpack，所以这两者之间是没有冲突的。
举个例子，说到js压缩，现在的人都用uglify，如果有多个要压缩的文件，咋办？你总不能一个一个去压缩吧。所以好事者就写脚本，写个.sh或者.bat什么的。幸运的是，gulp有uglify的插件，你就不用重复造轮子了。
1234567891011121314// 压缩jsgulp.task('jszip', function (callback) &#123;    pump(        [            gulp.src('app/**/*.js'),            uglify(&#123;                mangle: true,//类型：Boolean 默认：true 是否修改变量名                compress: true//类型：Boolean 默认：true 是否完全压缩            &#125;),            gulp.dest('dist')        ],        callback    );&#125;);
上面就是一个例子，把app文件夹下的js文件都压缩并打包到dist文件夹里。是不是很方便？
“看上去很牛逼，倒是讲讲怎么安装啊”
nodejs先稍微聊聊nodejs。gulp是基于nodejs的，而nodejs的流非常强大。

                
                    
                    
                
                gulp
            
“你说强大就强大，理由呢？”
当初的node还不叫nodejs，还在那纠结到底放到哪个语言上比较好。当时的语言，一遍观望下来，几乎都自带了一套I/O接口，而且是阻塞式的。node的设计者对这些都不太满意，但他们又不想重新发明一种语言，然后他们瞄上了js，js几乎是完美的选择，天然的异步方式，加上没有I/O接口，node果断加入了js阵营。异步非阻塞的模型是nodejs强大的根本原因。
     -->

    <h1 id="Gulp构建工具"><a href="#Gulp构建工具" class="headerlink" title="Gulp构建工具"></a>Gulp构建工具</h1><h2 id="gulp与webpack"><a href="#gulp与webpack" class="headerlink" title="gulp与webpack"></a>gulp与webpack</h2><ul>
<li>gulp是工具链、构建工具，可以配合各种插件做js压缩，css压缩，sass编译 替代手工实现自动化工作</li>
<li>webpack是文件打包工具，可以把项目的各种js文、css文件等打包合并成一个或多个文件，主要用于模块化方案，预编译模块的方案</li>
</ul>
<p>其实webpack很多功能gulp都能做，gulp甚至能够配置webpack，所以这两者之间是没有冲突的。</p>
<p>举个例子，说到js压缩，现在的人都用uglify，如果有多个要压缩的文件，咋办？你总不能一个一个去压缩吧。所以好事者就写脚本，写个.sh或者.bat什么的。幸运的是，gulp有uglify的插件，你就不用重复造轮子了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 压缩js</span></div><div class="line">gulp.task(<span class="string">'jszip'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">    pump(</div><div class="line">        [</div><div class="line">            gulp.src(<span class="string">'app/**/*.js'</span>),</div><div class="line">            uglify(&#123;</div><div class="line">                mangle: <span class="literal">true</span>,<span class="comment">//类型：Boolean 默认：true 是否修改变量名</span></div><div class="line">                compress: <span class="literal">true</span><span class="comment">//类型：Boolean 默认：true 是否完全压缩</span></div><div class="line">            &#125;),</div><div class="line">            gulp.dest(<span class="string">'dist'</span>)</div><div class="line">        ],</div><div class="line">        callback</div><div class="line">    );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面就是一个例子，把app文件夹下的js文件都压缩并打包到dist文件夹里。是不是很方便？</p>
<p>“看上去很牛逼，倒是讲讲怎么安装啊”</p>
<h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><p>先稍微聊聊nodejs。gulp是基于nodejs的，而nodejs的流非常强大。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_1.jpg" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure>
<p>“你说强大就强大，理由呢？”</p>
<p>当初的node还不叫nodejs，还在那纠结到底放到哪个语言上比较好。当时的语言，一遍观望下来，几乎都自带了一套I/O接口，而且是阻塞式的。<br>node的设计者对这些都不太满意，但他们又不想重新发明一种语言，然后他们瞄上了js，js几乎是完美的选择，天然的异步方式，加上没有I/O接口，node果断加入了js阵营。异步非阻塞的模型是nodejs强大的根本原因。</p>
<a id="more"></a>
<h3 id="I-O（题外话）"><a href="#I-O（题外话）" class="headerlink" title="I/O（题外话）"></a>I/O（题外话）</h3><p>“异步非阻塞怎么就强大了？wtf？”</p>
<p>我想问的是，你明白I/O吗？<br>“I/O不就是输入输出嘛，有什么大不了的。”<br>所以说，写操作系统的人是真正的大神，深藏功与名，因为他们已经为你准备好了一切。</p>
<p>从gulp讲到了I/O，感觉完全跑题了。。。呃，我本来就不是为了单纯介绍gulp构建工具，有兴趣的可以看看，再说，复习复习I/O没什么不好，不是吗=。=</p>
<p>I/O操作大致可以分为两部分:</p>
<ol>
<li>发出请求</li>
<li>结果完成</li>
</ol>
<p>I/O在操作系统中的四种模型（图来自Unix网络编程）：</p>
<ul>
<li>Blocking I/O 阻塞式I/O<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_2.png" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure>
</li>
</ul>
<p>计算机里要完成I/O操作，就会使用系统调用。</p>
<p>“系统调用是什么？”<br>额，这个就不讲了，否则越讲越偏。不要过多纠结在操作系统层面，这些模型是怎么实现的。<br>上图中的用户程序调用了recvfrom这个系统调用，kernel就开始了I/O的第一个阶段：准备数据。这个时候，kernel一直在等待足够的数据到达，与此同时，整个用户进程被阻塞。等准备好了之后，kernel返回结果，进程解除被block的状态。可以明显看到，kernel的两个状态，进程都是被阻塞的。</p>
<p>java里面的I/O处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">InputStream in = newConnection.getInputStream();</div><div class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(in);</div><div class="line">BufferedReader buffer = <span class="keyword">new</span> BufferedReader(reader);</div><div class="line">Request request = <span class="keyword">new</span> Request();</div><div class="line"><span class="keyword">while</span>(!request.isComplete()) &#123;</div><div class="line">    String line = buffer.readLine();<span class="comment">//阻塞</span></div><div class="line">        request.addLine(line);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>readLine()</code>是一个阻塞操作。</p>
<ul>
<li>Non-Blocking I/O 非阻塞式I/O<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_3.png" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure>
</li>
</ul>
<p>当用户进程发出read操作并调用系统调用，如果kernel中的数据还没准备好，此时它会马上返回一个结果，不会阻塞当前用户进程。一旦数据准备好，此时又再次收到了系统调用，那它就可以立即返回。唯一消耗的是，用户进程是在不断的主动询问kernel准备好数据没有。</p>
<ul>
<li>I/O multiplexing I/O复用</li>
</ul>
<p>大名鼎鼎的I/O复用。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_4.png" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure></p>
<p>I/O多路复用 (单个线程，通过记录跟踪每个I/O流(sock)的状态，来同时管理多个I/O流 。)<br>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<br>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking I/O只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_5.png" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure>
<p>就像拨码开关，哪里有数据拨向哪里。</p>
<ul>
<li>Asynchronous I/O 异步I/O</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_6.png" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure>
<p>可以看到，系统调用之后，并没有阻塞，而是依靠通知机制，当copy完了之后通知用户进程，可见这是纯异步的。发出后就不用任何等待，可以执行其他操作。</p>
<p>看到上面的解释，这些“异步”玩意儿，几乎都是操作系统层面的东西。那么nodejs所谓的异步非阻塞I/O是哪种？<br>还用说嘛，那不就是第四种。。。<br>但是你现在知道了，所谓的异步，是需要操作系统层面的支持的。如果没有或者有缺陷，就需要模拟。<br>Linux下有一个异步I/O的库，叫libeio，libeio实质上是采取线程池与阻塞式I/O模拟出来的异步I/O。<br>Windows下有独有的内核级异步I/O方案：IOCP。IOCP的思路是真正的异步I/O方案，调用异步方法，然后等待I/O完成通知。IOCP内部依旧是通过线程实现，不同在于这些线程由系统内核接手管理。IOCP的异步模型与Node.js的异步调用模型已经十分近似。<br>以上两种方案则正是Node.js选择的异步I/O方案。由于Windows平台和Unix平台的差异，Node.js提供了libuv来作为抽象封装层，使得所有平台兼容性的判断都由这一层次来完成，保证上层的Node.js与下层的libeio/libev及IOCP之间各自独立。Node.js在编译期间会判断平台条件，选择性编译unix目录或是win目录下的源文件到目标程序中。</p>
<h3 id="js中的异步"><a href="#js中的异步" class="headerlink" title="js中的异步"></a>js中的异步</h3><p>明确一点：</p>
<ul>
<li>js能异步是因为它用能调用的模块是异步的。js都是单线程的。而且只有一个事件队列（也可以理解成任务队列），他之所以异步是是因为某些的模块是异步的。当发送一个异步网络请求后，js的主线程不会一直等待这个请求返回，而是执行事件队列里下一个事件。请注意，js并没有实现如何发送网络请求，js只是调用了某个能发送网络请求的模块，而这个模块是通过c++或其他语言实现。然后这个模块在等待请求的结果，当得到响应后，便把响应成功这个事件添加到js的事件队列的队尾。网络请求发送的同时，js依然在执行，这显然是异步的。</li>
</ul>
<p>可以通俗地认为，nodejs的函数基本都是默认异步的。</p>
<p>（ps：听上去很屌的样子，写个复制看看？不用写了，光是比复制怎么比得过嘛。再凶也凶不过系统原生的copy啊。。。有些人写复制来证明node很快，蛋疼不蛋疼？实测比系统复制慢一倍。）</p>
<h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h2><p>一般通用的web app项目结构:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_10.png" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure>
<h3 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h3><p><a href="http://nodejs.cn/download/" target="_blank" rel="external">http://nodejs.cn/download/</a></p>
<p>装完之后，就有了NPM包管理器。像这样的：</p>
<p>可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init</div></pre></td></tr></table></figure></p>
<p>这个用来初始化你的package.json。</p>
<p>这是我项目里的package.json配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"vrf"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">  <span class="attr">"description"</span>: <span class="string">"vrf project"</span>,</div><div class="line">  <span class="attr">"main"</span>: <span class="string">"gulpfile.js"</span>,</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">    <span class="attr">"start"</span>: <span class="string">"webpack"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"repository"</span>: &#123;</div><div class="line">    <span class="attr">"type"</span>: <span class="string">"git"</span>,</div><div class="line">    <span class="attr">"url"</span>: <span class="string">"http://xxxxx/susan/xxx.git"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"keywords"</span>: [</div><div class="line">    <span class="string">"vrf"</span></div><div class="line">  ],</div><div class="line">  <span class="attr">"author"</span>: <span class="string">"susan,hwb,leesure"</span>,</div><div class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"babel-preset-es2015"</span>: <span class="string">"^6.24.1"</span>,</div><div class="line">    <span class="attr">"browser-sync"</span>: <span class="string">"^2.18.8"</span>,</div><div class="line">    <span class="attr">"cheerio"</span>: <span class="string">"^1.0.0-rc.1"</span>,</div><div class="line">    <span class="attr">"child_process"</span>: <span class="string">"^1.0.2"</span>,</div><div class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^0.28.0"</span>,</div><div class="line">    <span class="attr">"del"</span>: <span class="string">"^2.2.2"</span>,</div><div class="line">    <span class="attr">"gulp"</span>: <span class="string">"^3.9.1"</span>,</div><div class="line">    <span class="attr">"gulp-babel"</span>: <span class="string">"^6.1.2"</span>,</div><div class="line">    <span class="attr">"gulp-clean-css"</span>: <span class="string">"^3.0.4"</span>,</div><div class="line">    <span class="attr">"gulp-concat"</span>: <span class="string">"^2.6.1"</span>,</div><div class="line">    <span class="attr">"gulp-htmlmin"</span>: <span class="string">"^3.0.0"</span>,</div><div class="line">    <span class="attr">"gulp-if"</span>: <span class="string">"^2.0.2"</span>,</div><div class="line">    <span class="attr">"gulp-imagemin"</span>: <span class="string">"^3.2.0"</span>,</div><div class="line">    <span class="attr">"gulp-jasmine"</span>: <span class="string">"^2.4.2"</span>,</div><div class="line">    <span class="attr">"gulp-jasmine-browser"</span>: <span class="string">"^1.7.1"</span>,</div><div class="line">    <span class="attr">"gulp-jsdoc3"</span>: <span class="string">"^1.0.1"</span>,</div><div class="line">    <span class="attr">"gulp-jsduck"</span>: <span class="string">"^1.0.0"</span>,</div><div class="line">    <span class="attr">"gulp-minify-css"</span>: <span class="string">"^1.2.4"</span>,</div><div class="line">    <span class="attr">"gulp-qunit"</span>: <span class="string">"^1.5.0"</span>,</div><div class="line">    <span class="attr">"gulp-rename"</span>: <span class="string">"^1.2.2"</span>,</div><div class="line">    <span class="attr">"gulp-sequence"</span>: <span class="string">"^0.4.6"</span>,</div><div class="line">    <span class="attr">"gulp-uglify"</span>: <span class="string">"^2.1.2"</span>,</div><div class="line">    <span class="attr">"gulp-useref"</span>: <span class="string">"^3.1.2"</span>,</div><div class="line">    <span class="attr">"gulp-util"</span>: <span class="string">"^3.0.8"</span>,</div><div class="line">    <span class="attr">"gulp-watch"</span>: <span class="string">"^4.3.11"</span>,</div><div class="line">    <span class="attr">"gulp-webserver"</span>: <span class="string">"^0.9.1"</span>,</div><div class="line">    <span class="attr">"jsdoc"</span>: <span class="string">"^3.4.3"</span>,</div><div class="line">    <span class="attr">"jsduck"</span>: <span class="string">"^1.1.2"</span>,</div><div class="line">    <span class="attr">"jsx-loader"</span>: <span class="string">"^0.13.2"</span>,</div><div class="line">    <span class="attr">"merge-stream"</span>: <span class="string">"^1.0.1"</span>,</div><div class="line">    <span class="attr">"pngquant"</span>: <span class="string">"^1.2.0"</span>,</div><div class="line">    <span class="attr">"pump"</span>: <span class="string">"^1.0.2"</span>,</div><div class="line">    <span class="attr">"qunit"</span>: <span class="string">"^1.0.0"</span>,</div><div class="line">    <span class="attr">"run-sequence"</span>: <span class="string">"^1.2.2"</span>,</div><div class="line">    <span class="attr">"sass-loader"</span>: <span class="string">"^6.0.3"</span>,</div><div class="line">    <span class="attr">"style-loader"</span>: <span class="string">"^0.16.1"</span>,</div><div class="line">    <span class="attr">"url-loader"</span>: <span class="string">"^0.5.8"</span>,</div><div class="line">    <span class="attr">"webpack-stream"</span>: <span class="string">"^3.2.0"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"directories"</span>: &#123;</div><div class="line">    <span class="attr">"doc"</span>: <span class="string">"docs"</span>,</div><div class="line">    <span class="attr">"test"</span>: <span class="string">"test"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"devDependencies"</span>: &#123;</div><div class="line">    <span class="attr">"gulp-obfuscate"</span>: <span class="string">"^0.2.9"</span>,</div><div class="line">    <span class="attr">"gulp-uglify"</span>: <span class="string">"^2.1.2"</span>,</div><div class="line">    <span class="attr">"uglify"</span>: <span class="string">"^0.1.5"</span>,</div><div class="line">    <span class="attr">"uglify-js"</span>: <span class="string">"^3.0.18"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个json相当于依赖配置文件，项目根据它里面定义所依赖的第三方包进行配置。<br>不明白？好，android的gradle懂吧？iOS的CocoaPods懂吧？</p>
<h3 id="gulp安装"><a href="#gulp安装" class="headerlink" title="gulp安装"></a>gulp安装</h3><ol>
<li>全局安装 gulp：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --global gulp</div></pre></td></tr></table></figure>
<ol>
<li>作为项目的开发依赖（devDependencies）安装：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev gulp</div></pre></td></tr></table></figure>
<ol>
<li>在项目根目录下创建一个名为 gulpfile.js 的文件：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 将你的默认的任务代码放在这</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>运行 gulp：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gulp</div></pre></td></tr></table></figure>
<p>默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。</p>
<p>想要单独执行特定的任务（task），请输入 gulp &lt;<em>task</em>&gt; &lt;<em>othertask</em>&gt;。</p>
<h3 id="gulp速览"><a href="#gulp速览" class="headerlink" title="gulp速览"></a>gulp速览</h3><p>其实，gulp的操作都是一些插件的运用，你只需要知道四个东西：</p>
<ol>
<li>gulp.task()</li>
<li>gulp.src()</li>
<li>gulp.dest()</li>
<li>gulp.watch()</li>
</ol>
<h4 id="gulp-task-names-deps-fn"><a href="#gulp-task-names-deps-fn" class="headerlink" title="gulp.task(names[,deps,fn])"></a>gulp.task(names[,deps,fn])</h4><p>gulp.task方法用来定义任务，<br>name 为任务名，<br>deps 是当前定义的任务需要依赖的其他任务，<br>为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。<br>如果没有依赖，则可省略这个参数，<br>fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。</p>
<h4 id="gulp-src-globs-options"><a href="#gulp-src-globs-options" class="headerlink" title="gulp.src(globs[,options])"></a>gulp.src(globs[,options])</h4><p>gulp.src()方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息，本文暂不对文件流进行展开，你只需简单的理解可以用这个方法来读取你需要操作的文件就行了，globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组。<br>options为可选参数。通常情况下我们不需要用到，暂不考虑。</p>
<p>文件匹配模式<br>Gulp内部使用了node-glob模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件：</p>
<p><code>*</code> 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾<br><code>**</code> 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。<br><code>?</code>匹配文件路径中的一个字符(不会匹配路径分隔符)<br><code>[...]</code> 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法!(pattern|pattern|pattern)匹配任何与括号中给定的任一模式都不匹配的<br><code>?(pattern|pattern|pattern)</code>匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)?<br><code>+(pattern|pattern|pattern)</code>匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+<br><code>*(pattern|pattern|pattern)</code>匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)*<br><code>@(pattern|pattern|pattern)</code>匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern)<br>文件匹配列子：</p>
<p><code>*</code> 能匹配 reeoo.js,reeoo.css,reeoo,reeoo/,但不能匹配reeoo/reeoo.js<br><code>*.*</code>能匹配 reeoo.js,reeoo.css,reeoo.html<br><code>*/*/*.js</code>能匹配 r/e/o.js,a/b/c.js,不能匹配a/b.js,a/b/c/d.js<br><code>**</code>能匹配 reeoo,reeoo/reeoo.js,reeoo/reeoo/reeoo.js,reeoo/reeoo/reeoo,reeoo/reeoo/reeoo/reeoo.co,能用来匹配所有的目录和文件<br><code>**/*.js</code>能匹配 reeoo.js,reeoo/reeoo.js,reeoo/reeoo/reeoo.js,reeoo/reeoo/reeoo/reeoo.js<br><code>reeoo/**/co</code>能匹配 reeoo/co,reeoo/ooo/co,reeoo/a/b/co,reeoo/d/g/h/j/k/co<br><code>reeoo/**b/co</code>能匹配 reeoo/b/co,reeoo/sb/co,但不能匹配reeoo/x/sb/co,因为只有单**单独出现才能匹配多级目录<br><code>?.js</code>能匹配 reeoo.js,reeoo1.js,reeoo2.js<br><code>reeoo??</code>能匹配 reeoo.co,reeooco,但不能匹配reeooco/,因为它不会匹配路径分隔符<br><code>[reo].js</code>只能匹配 r.js,e.js,o.js,不会匹配re.js,reo.js等,整个中括号只代表一个字符<br><code>[^reo].js</code>能匹配 a.js,b.js,c.js等,不能匹配r.js,e.js,o.js<br>当有多种匹配模式时可以使用数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用数组的方式来匹配多种文</span></div><div class="line">gulp.src([<span class="string">'js/*.js'</span>,<span class="string">'css/*.css'</span>,<span class="string">'*.html'</span>])</div></pre></td></tr></table></figure>
<p>使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上!即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式</p>
<p><code>gulp.src([*.js,&#39;!r*.js&#39;])</code> 匹配所有js文件，但排除掉以r开头的js文件<br><code>gulp.src([&#39;!r*.js&#39;,*.js])</code> 不会排除任何文件，因为排除模式不能出现在数组的第一个元素中<br>此外，还可以使用展开模式。展开模式以花括号作为定界符，根据它里面的内容，会展开为多个模式，最后匹配的结果为所有展开的模式相加起来得到的结果。展开的例子如下：</p>
<p><code>r{e,o}c</code>会展开为 rec,roc<br><code>r{e,}o</code>会展开为 reo,ro<br><code>r{0..3}o</code>会展开为 r0o,r1do,r2o,r3o</p>
<h4 id="gulp-dest-path-options"><a href="#gulp-dest-path-options" class="headerlink" title="gulp.dest(path[,options])"></a>gulp.dest(path[,options])</h4><p>gulp.dest()方法是用来写文件的，path为写入文件的路径,options为一个可选的参数对象，通常我们不需要用到，暂不考虑。<br>要想使用好gulp.dest()这个方法，就要理解给它传入的路径参数与最终生成的文件的关系。<br>gulp的使用流程一般是这样子的：首先通过gulp.src()方法获取到我们想要处理的文件流，然后把文件流通过pipe方法导入到gulp的插件中，最后把经过插件处理后的流再通过pipe方法导入到gulp.dest()中，gulp.dest()方法则把流中的内容写入到文件中，这里首先需要弄清楚的一点是，我们给gulp.dest()传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以生成的文件名是由导入到它的文件流决定的，即使我们给它传入一个带有文件名的路径参数，然后它也会把这个文件名当做是目录名，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line">gulp.src(<span class="string">'script/jquery.js'</span>)</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/foo.js'</span>));</div><div class="line"><span class="comment">//最终生成的文件路径为 dist/foo.js/jquery.js,而不是dist/foo.js</span></div></pre></td></tr></table></figure></p>
<p>要想改变文件名，可以使用插件gulp-rename</p>
<p>下面说说生成的文件路径与我们给gulp.dest()方法传入的路径参数之间的关系。<br>gulp.dest(path)生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = reruire(<span class="string">'gulp'</span>);</div><div class="line"><span class="comment">//有通配符开始出现的那部分路径为 **/*.js</span></div><div class="line">gulp.src(<span class="string">'script/**/*.js'</span>)</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>)); <span class="comment">//最后生成的文件路径为 dist/**/*.js</span></div><div class="line"><span class="comment">//如果 **/*.js 匹配到的文件为 jquery/jquery.js ,则生成的文件路径为 dist/jquery/jquery.js</span></div></pre></td></tr></table></figure></p>
<p>再举更多一点的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'script/avalon/avalon.js'</span>) <span class="comment">//没有通配符出现的情况</span></div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>)); <span class="comment">//最后生成的文件路径为 dist/avalon.js</span></div><div class="line"></div><div class="line"><span class="comment">//有通配符开始出现的那部分路径为 **/underscore.js</span></div><div class="line">gulp.src(<span class="string">'script/**/underscore.js'</span>)</div><div class="line">    <span class="comment">//假设匹配到的文件为script/util/underscore.js</span></div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>)); <span class="comment">//则最后生成的文件路径为 dist/util/underscore.js</span></div><div class="line"></div><div class="line">gulp.src(<span class="string">'script/*'</span>) <span class="comment">//有通配符出现的那部分路径为 *</span></div><div class="line">    <span class="comment">//假设匹配到的文件为script/zepto.js</span></div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>)); <span class="comment">//则最后生成的文件路径为 dist/zepto.js</span></div></pre></td></tr></table></figure></p>
<p>通过指定gulp.src()方法配置参数中的base属性，我们可以更灵活的来改变gulp.dest()生成的文件路径。<br>当我们没有在gulp.src()方法中配置base属性时，base的默认值为通配符开始出现之前那部分路径，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'app/src/**/*.css'</span>) <span class="comment">//此时base的值为 app/src</span></div></pre></td></tr></table></figure></p>
<p>上面我们说的gulp.dest()所生成的文件路径的规则，其实也可以理解成，用我们给gulp.dest()传入的路径替换掉gulp.src()中的base路径，最终得到生成文件的路径。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'app/src/**/*.css'</span>) <span class="comment">//此时base的值为app/src,也就是说它的base路径为app/src</span></div><div class="line">     <span class="comment">//设该模式匹配到了文件 app/src/css/normal.css</span></div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>)) <span class="comment">//用dist替换掉base路径，最终得到 dist/css/normal.css</span></div></pre></td></tr></table></figure></p>
<p>所以改变base路径后，gulp.dest()生成的文件路径也会改变</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gulp.src(script/lib<span class="comment">/*.js) //没有配置base参数，此时默认的base路径为script/lib</span></div><div class="line"><span class="comment">    //假设匹配到的文件为script/lib/jquery.js</span></div><div class="line"><span class="comment">    .pipe(gulp.dest('build')) //生成的文件路径为 build/jquery.js</span></div><div class="line"><span class="comment">gulp.src(script/lib/*.js, &#123;base:'script'&#125;) //配置了base参数，此时base路径为script</span></div><div class="line"><span class="comment">    //假设匹配到的文件为script/lib/jquery.js</span></div><div class="line"><span class="comment">    .pipe(gulp.dest('build')) //此时生成的文件路径为 build/lib/jquery.js</span></div></pre></td></tr></table></figure>
<p>用gulp.dest()把文件流写入文件后，文件流仍然可以继续使用。</p>
<h4 id="gulp-watch-glob-opts-tasks"><a href="#gulp-watch-glob-opts-tasks" class="headerlink" title="gulp.watch(glob[,opts],tasks)"></a>gulp.watch(glob[,opts],tasks)</h4><p>gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。<br>glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。<br>opts 为一个可选的配置对象，通常不需要用到，暂不考虑。<br>tasks 为文件变化后要执行的任务，为一个数组，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'uglify'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//do something</span></div><div class="line">&#125;);</div><div class="line">gulp.task(<span class="string">'reload'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//do something</span></div><div class="line">&#125;);</div><div class="line">gulp.watch(<span class="string">'js/**/*.js'</span>, [<span class="string">'uglify'</span>,<span class="string">'reload'</span>]);</div></pre></td></tr></table></figure></p>
<p>gulp.watch()还有另外一种使用方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp.watch(glob[, opts, cb])</div></pre></td></tr></table></figure>
<p>glob和opts参数与第一种用法相同<br>cb参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type属性为变化的类型，可以是added,changed,deleted；path属性为发生变化的文件的路径<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gulp.watch(<span class="string">'js/**/*.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.type); <span class="comment">//变化类型 added为新增,deleted为删除，changed为改变 </span></div><div class="line">    <span class="built_in">console</span>.log(event.path); <span class="comment">//变化的文件的路径</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="gulp插件的使用"><a href="#gulp插件的使用" class="headerlink" title="gulp插件的使用"></a>gulp插件的使用</h3><p>安装gulp插件都是通过npm安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev xxxxx</div></pre></td></tr></table></figure></p>
<h4 id="gulp-sourcemaps"><a href="#gulp-sourcemaps" class="headerlink" title="gulp-sourcemaps"></a>gulp-sourcemaps</h4><p>source map是什么？</p>
<ul>
<li>从源码转换讲起<br>JavaScript脚本正变得越来越复杂。大部分源码（尤其是各种函数库和框架）都要经过转换，才能投入生产环境。</li>
</ul>
<p>常见的源码转换，主要是以下三种情况：</p>
<ol>
<li>压缩，减小体积。比如jQuery 1.9的源码，压缩前是252KB，压缩后是32KB。</li>
<li>多个文件合并，减少HTTP请求数。</li>
<li>其他语言编译成JavaScript。最常见的例子就是CoffeeScript。<br>这三种情况，都使得实际运行的代码不同于开发代码，除错（debug）变得困难重重。</li>
</ol>
<p>通常，JavaScript的解释器会告诉你，第几行第几列代码出错。但是，这对于转换后的代码毫无用处。举例来说，jQuery 1.9压缩后只有3行，每行3万个字符，所有内部变量都改了名字。你看着报错信息，感到毫无头绪，根本不知道它所对应的原始位置。</p>
<p>这就是Source map想要解决的问题。</p>
<p>简单说，Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。</p>
<p>有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。</p>
<h4 id="gulp-uglify"><a href="#gulp-uglify" class="headerlink" title="gulp-uglify"></a>gulp-uglify</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev gulp-uglify</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 压缩js</span></div><div class="line">gulp.task(<span class="string">'jszip'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">    pump(</div><div class="line">        [</div><div class="line">            gulp.src(<span class="string">'app/**/*.js'</span>),</div><div class="line">            sourcemaps.init(),</div><div class="line">            uglify(&#123;</div><div class="line">                mangle: <span class="literal">true</span>,<span class="comment">//类型：Boolean 默认：true 是否修改变量名</span></div><div class="line">                compress: <span class="literal">true</span><span class="comment">//类型：Boolean 默认：true 是否完全压缩</span></div><div class="line">            &#125;),</div><div class="line">            sourcemaps.write(),</div><div class="line">            <span class="comment">// obfuscate(),</span></div><div class="line">            gulp.dest(<span class="string">'dist'</span>)</div><div class="line">        ],</div><div class="line">        callback</div><div class="line">    );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这其中用到了pump插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install --save-dev pump</div></pre></td></tr></table></figure></p>
<p>它是用来取代nodejs原生的pipe，主要是它能定位错误信息。</p>
<h4 id="gulp-clean-css"><a href="#gulp-clean-css" class="headerlink" title="gulp-clean-css"></a>gulp-clean-css</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install --save-dev gulp-clean-css</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//压缩css</span></div><div class="line">gulp.task(<span class="string">'csszip'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">    pump(</div><div class="line">        [</div><div class="line">            gulp.src([<span class="string">'app/**/*.css'</span>]),</div><div class="line">            sourcemaps.init(),</div><div class="line">            minicss(),</div><div class="line">            sourcemaps.write(),</div><div class="line">            gulp.dest(<span class="string">'dist'</span>)</div><div class="line">        ],</div><div class="line">        callback</div><div class="line">    );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="gulp-htmlmin"><a href="#gulp-htmlmin" class="headerlink" title="gulp-htmlmin"></a>gulp-htmlmin</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install --save-dev gulp-htmlmin</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//压缩html</span></div><div class="line">gulp.task(<span class="string">'htmlzip'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">    pump(</div><div class="line">        [</div><div class="line">            gulp.src(<span class="string">'app/**/*.html'</span>),</div><div class="line">            htmlmin(&#123;</div><div class="line">                removeComments: <span class="literal">true</span>,<span class="comment">//清除HTML注释</span></div><div class="line">                collapseWhitespace: <span class="literal">true</span>,<span class="comment">//压缩HTML</span></div><div class="line">                collapseBooleanAttributes: <span class="literal">true</span>,<span class="comment">//省略布尔属性的值 &lt;input checked="true"/&gt; ==&gt; &lt;input /&gt;</span></div><div class="line">                removeEmptyAttributes: <span class="literal">true</span>,<span class="comment">//删除所有空格作属性值 &lt;input id="" /&gt; ==&gt; &lt;input /&gt;</span></div><div class="line">                removeScriptTypeAttributes: <span class="literal">true</span>,<span class="comment">//删除&lt;script&gt;的type="text/javascript"</span></div><div class="line">                removeStyleLinkTypeAttributes: <span class="literal">true</span>,<span class="comment">//删除&lt;style&gt;和&lt;link&gt;的type="text/css"</span></div><div class="line">                minifyJS: <span class="literal">true</span>,<span class="comment">//压缩页面JS</span></div><div class="line">                minifyCSS: <span class="literal">true</span><span class="comment">//压缩页面CSS</span></div><div class="line">            &#125;),</div><div class="line">            gulp.dest(<span class="string">'dist'</span>)</div><div class="line">        ],</div><div class="line">        callback</div><div class="line">    );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="gulp-imagemin与pngquant"><a href="#gulp-imagemin与pngquant" class="headerlink" title="gulp-imagemin与pngquant"></a>gulp-imagemin与pngquant</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//压缩图片</span></div><div class="line">gulp.task(<span class="string">'imgzip'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">    pump(</div><div class="line">        [</div><div class="line">            gulp.src([<span class="string">'app/**/*.png'</span>, <span class="string">'app/**/*.jpeg'</span>, <span class="string">'app/**/*.gif'</span>]),</div><div class="line">            imagemin(</div><div class="line">                &#123;</div><div class="line">                    optimizationLevel: <span class="number">5</span>, <span class="comment">//类型：Number  默认：3  取值范围：0-7（优化等级）</span></div><div class="line">                    progressive: <span class="literal">true</span>,</div><div class="line">                    svgoPlugins: [&#123;<span class="attr">removeViewBox</span>: <span class="literal">false</span>&#125;],<span class="comment">//不要移除svg的viewbox属性</span></div><div class="line">                    use: [pngquant()] <span class="comment">//使用pngquant深度压缩png图片的imagemin插件</span></div><div class="line">                &#125;</div><div class="line">            ),</div><div class="line">            gulp.dest(<span class="string">'dist'</span>)</div><div class="line">        ],</div><div class="line">        callback</div><div class="line">    );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="gulp-sass"><a href="#gulp-sass" class="headerlink" title="gulp-sass"></a>gulp-sass</h4><p>sass是一个css预编译器，这里不做过多介绍。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</div><div class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> gulp.src(<span class="string">'./sass/**/*.scss'</span>)</div><div class="line">  .pipe(sourcemaps.init())</div><div class="line">  .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</div><div class="line">  .pipe(sourcemaps.write(<span class="string">'./maps'</span>))</div><div class="line">  .pipe(gulp.dest(<span class="string">'./css'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="gulp-sequence"><a href="#gulp-sequence" class="headerlink" title="gulp-sequence"></a>gulp-sequence</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> runSequence=<span class="built_in">require</span>(<span class="string">'gulp-sequence'</span>);</div><div class="line"></div><div class="line"><span class="comment">//异步执行压缩任务</span></div><div class="line">gulp.task(<span class="string">'default'</span>,</div><div class="line">    runSequence(<span class="string">'clear'</span>, [<span class="string">'parsezip'</span>, <span class="string">'imgzip'</span>, <span class="string">'htmlzip'</span>, <span class="string">'csszip'</span>, <span class="string">'jszip'</span>, <span class="string">'font'</span>, <span class="string">'doc'</span>], <span class="string">'copy'</span></div><div class="line">    )</div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="gulp-concat"><a href="#gulp-concat" class="headerlink" title="gulp-concat"></a>gulp-concat</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//合并js</span></div><div class="line">gulp.task(<span class="string">'parsezip'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">    pump(</div><div class="line">        [</div><div class="line">            gulp.src([<span class="string">'app/js/json/state-inner.js'</span>,</div><div class="line">                <span class="string">'app/js/json/state-outdoor.js'</span>,</div><div class="line">                <span class="string">'app/js/json/state-basic.js'</span>,</div><div class="line">                <span class="string">'app/js/json/hex-unit.js'</span>,</div><div class="line">                <span class="string">'app/js/json/hex-parse-inner.js'</span>,</div><div class="line">                <span class="string">'app/js/json/hex-parse-outdoor.js'</span>,</div><div class="line">                <span class="string">'app/js/json/hex-parse-basic.js'</span>,</div><div class="line">                <span class="string">'app/js/json/json-parse-frame.js'</span>,</div><div class="line">                <span class="string">'app/js/json/json-send-frame.js'</span>]),</div><div class="line">            concat(<span class="string">'parsedata.min.js'</span>),</div><div class="line">            gulp.dest(<span class="string">'app/js/json'</span>)</div><div class="line">        ],</div><div class="line">        callback</div><div class="line">    );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="gulp-jsdoc3"><a href="#gulp-jsdoc3" class="headerlink" title="gulp-jsdoc3"></a>gulp-jsdoc3</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生成注释文档</span></div><div class="line">gulp.task(<span class="string">'doc'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'./jsdoc-config.json'</span>);</div><div class="line">    gulp.src([<span class="string">'./app/**/*.js'</span>], &#123;<span class="attr">read</span>: <span class="literal">false</span>&#125;)</div><div class="line">        .pipe(jsdoc(config, cb));</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="gulp-jasmine"><a href="#gulp-jasmine" class="headerlink" title="gulp-jasmine"></a>gulp-jasmine</h4><p>这是一个单元测试插件，jasmine是一个单元测试框架，类似的还有Qunit。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jasmineBrowser = <span class="built_in">require</span>(<span class="string">'gulp-jasmine-browser'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'jasmine'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> files = [<span class="string">'./test/src/**/*.js'</span>, <span class="string">'./test/spec/**/*.js'</span>, <span class="string">'app/js/**/*.js'</span>];</div><div class="line">    <span class="keyword">return</span> gulp.src(files)</div><div class="line">        .pipe(watch(files))</div><div class="line">        .pipe(jasmineBrowser.specRunner())</div><div class="line">        .pipe(jasmineBrowser.server(&#123;<span class="attr">port</span>: <span class="number">9199</span>&#125;))</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="gulp-webpack"><a href="#gulp-webpack" class="headerlink" title="gulp-webpack"></a>gulp-webpack</h4><p>gulp是可以和webpack配合的，而且gulp的uglify不能直接压缩ES6的代码。<br>什么，你跟我说gulp-babel？是的，我说的是gulp-babel，实际过程中，gulp-babel也遇上一些问题，不能转码。而且出问题的一些第三方库，又不想去改它，心里想也许切换成webpack的方案来进行转码或许就可以。</p>
<p>gulp-webpack就是这样的插件，它可以让webpack的配置嵌入到gulp中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'gulp-webpack'</span>);</div><div class="line">gulp.task(<span class="string">'webpack'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./xxxx.js'</span>)</div><div class="line">    .pipe(webpack(&#123;</div><div class="line">        <span class="built_in">module</span>: &#123;</div><div class="line">        loaders: [</div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">loader</span>: <span class="string">'babel-loader'</span> &#125;,</div><div class="line">        ],</div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line">    ))</div><div class="line">    .pipe(rename(<span class="string">'/xxxx.js'</span>))</div><div class="line">    .pipe(gulp.dest(<span class="string">'./dist'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>同样地，你可以使用<code>webpack.config.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> gulp.src(<span class="string">'src/entry.js'</span>)</div><div class="line">  .pipe(webpack( <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>) ))</div><div class="line">  .pipe(gulp.dest(<span class="string">'dist/'</span>));</div></pre></td></tr></table></figure>
<h3 id="jenkins与gulp配合"><a href="#jenkins与gulp配合" class="headerlink" title="jenkins与gulp配合"></a>jenkins与gulp配合</h3><p>jenkins是一个持续集成工具，就是一个监控持续重复工作的工具。</p>
<h4 id="jenkins安装"><a href="#jenkins安装" class="headerlink" title="jenkins安装"></a>jenkins安装</h4><p>下载地址：<br><a href="https://jenkins.io/download/" target="_blank" rel="external">https://jenkins.io/download/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar jenkins.war</div></pre></td></tr></table></figure>
<p>静静等待安装完毕。。。</p>
<h4 id="jenkins配置"><a href="#jenkins配置" class="headerlink" title="jenkins配置"></a>jenkins配置</h4><p>首先，新建一个项目。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_11.png" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure></p>
<p>设置源码仓库地址：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_12.png" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure></p>
<p>触发器设置：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_13.png" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure></p>
<ul>
<li><em>/10 </em> <em> </em> * 代表每10分钟监测源码库，并执行构建。</li>
</ul>
<p>构建环境配置：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_14.png" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure></p>
<p>构建配置：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_15.png" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/gulp_16.png" alt="gulp" title="">
                </div>
                <div class="image-caption">gulp</div>
            </figure></p>
<p>因为在项目里面有gulpfile.js，所以这里唯一需要的东西就是node环境了。其他都可以用cnpm install然后执行gulp任务即可。</p>
<p>关于gulp的基本使用到此介绍完毕。</p>

        <a href="/2017/06/27/gulp构建工具/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gulp/">gulp</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-红黑树"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2017-06-25 15:54:07" datetime="2017-06-25T07:54:07.000Z"  itemprop="datePublished">2017-06-25</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/算法/">算法</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2017/06/25/红黑树/">红黑树</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    <!-- 
        红黑树
红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，他称之为”对称二叉B树”，它现代的名字是在Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。

维基百科上的定义就这么说了。好像你看了之后也不知道它究竟是啥。因为红黑树本身是非常绅士（hentai）的数据结构。“自平衡二叉查找树？什么是平衡树？什么是二叉查找树？”不得不说这由红黑树引发的关于Data Structure知识匮乏的一系列惨案。。。
二叉查找树回顾一下二叉查找树吧。它满足以下性质：

若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
任意节点的左、右子树也分别为二叉查找树；
没有键值相等的节点。

如何构造一颗二叉查找树？
首先一颗BST要包含插入、删除和查找等操作。
先定义一个节点：123456789101112131415161718class Node(object):    def __init__(self,k,l=None,r=None,p=None):        self.lchild=l        self.rchild=r        self.parent=p        self.key=k    def has_left_child(self):        return self.lchild        def has_right_child(self):        return self.rchild    def is_left_child(self):        return self.parent and self.parent.lchild==self    def is_right_child(self):        return self.parent and self.parent.rchild==self
初始化一棵树：
1234class BinarySearchTree(object):    def __init__(self):        self.root=None        self.node_size=0
此时，根节点为空，大小为0，还没开始插入节点。
所以，插入考虑两种情况：

插入的是根节点
插入的不是根节点

插入根节点不用多说，但插入子节点有讲究，根据二叉查找树的定义，具体看代码：
1234567891011121314151617181920212223242526def insert(self,x):        node= Node(x)        if not self.root:            self.root=node            self.node_size=1        else:            current_node=self.root            while True:                if x&lt;current_node.key:                      #x如果小于当前节点的key，则想办法弄到左边                    if current_node.lchild:                 #已经有了，则把比较目标切成左子树的根节点                        current_node=current_node.lchild                    else:                                   #若没有，直接插入                        current_node.lchild=node                        node.parent=current_node                        self.node_size+=1                        break                elif x&gt;current_node.key:                    #x大于key，则弄到右边                    if current_node.rchild:                 #已经有了，则把比较目标切成右子树的根节点                        current_node=current_node.rchild                    else:                                   #若没有，直接插入                        current_node.rchild=node                        node.parent=current_node                        self.node_size+=1                        break                else:                    break
插入了之后，就可以查找节点了，查找相当简单，多亏了这是二叉排序树，你只需要从金字塔顶端往下走就行，遇上小的往左，遇上大的往右，直到碰到和自己一样的：
1234567891011121314def find(self,x):        current_node=self.root        while True:            if not current_node:                result=None                break            elif x&lt;current_node.key:                current_node=current_node.lchild            elif x&gt;current_node.key:                current_node=current_node.rchild            else:                result=current_node                break        return result
呵呵，挺好的，貌似差不多了，，，不过还有删除呢。删除这个操作，是二叉树里最烦的操作了。它涉及到各种情况，虽然写法不一，但思路都是一样，无外乎包含这四种情况：

被删节点是叶节点（不够准确，其实是既无左子树又无右子树）
被删节点有左子树但没有右子树
被删节点有右子树但没有左子树
被删节点左右子树都有

     -->

    <h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ul>
<li>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，他称之为”对称二叉B树”，它现代的名字是在Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。</li>
</ul>
<p>维基百科上的定义就这么说了。好像你看了之后也不知道它究竟是啥。因为红黑树本身是非常绅士（hentai）的数据结构。“自平衡二叉查找树？什么是平衡树？什么是二叉查找树？”<br>不得不说这由红黑树引发的关于Data Structure知识匮乏的一系列惨案。。。</p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>回顾一下二叉查找树吧。它满足以下性质：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ol>
<p>如何构造一颗二叉查找树？</p>
<p>首先一颗BST要包含插入、删除和查找等操作。</p>
<p>先定义一个节点：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,k,l=None,r=None,p=None)</span>:</span></div><div class="line">        self.lchild=l</div><div class="line">        self.rchild=r</div><div class="line">        self.parent=p</div><div class="line">        self.key=k</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_left_child</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.lchild</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_right_child</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.rchild</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_left_child</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.parent <span class="keyword">and</span> self.parent.lchild==self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_right_child</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.parent <span class="keyword">and</span> self.parent.rchild==self</div></pre></td></tr></table></figure></p>
<p>初始化一棵树：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.root=<span class="keyword">None</span></div><div class="line">        self.node_size=<span class="number">0</span></div></pre></td></tr></table></figure>
<p>此时，根节点为空，大小为0，还没开始插入节点。</p>
<p>所以，插入考虑两种情况：</p>
<ol>
<li>插入的是根节点</li>
<li>插入的不是根节点</li>
</ol>
<p>插入根节点不用多说，但插入子节点有讲究，根据二叉查找树的定义，具体看代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,x)</span>:</span></div><div class="line">        node= Node(x)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.root:</div><div class="line">            self.root=node</div><div class="line">            self.node_size=<span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            current_node=self.root</div><div class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">                <span class="keyword">if</span> x&lt;current_node.key:                      <span class="comment">#x如果小于当前节点的key，则想办法弄到左边</span></div><div class="line">                    <span class="keyword">if</span> current_node.lchild:                 <span class="comment">#已经有了，则把比较目标切成左子树的根节点</span></div><div class="line">                        current_node=current_node.lchild</div><div class="line">                    <span class="keyword">else</span>:                                   <span class="comment">#若没有，直接插入</span></div><div class="line">                        current_node.lchild=node</div><div class="line">                        node.parent=current_node</div><div class="line">                        self.node_size+=<span class="number">1</span></div><div class="line">                        <span class="keyword">break</span></div><div class="line">                <span class="keyword">elif</span> x&gt;current_node.key:                    <span class="comment">#x大于key，则弄到右边</span></div><div class="line">                    <span class="keyword">if</span> current_node.rchild:                 <span class="comment">#已经有了，则把比较目标切成右子树的根节点</span></div><div class="line">                        current_node=current_node.rchild</div><div class="line">                    <span class="keyword">else</span>:                                   <span class="comment">#若没有，直接插入</span></div><div class="line">                        current_node.rchild=node</div><div class="line">                        node.parent=current_node</div><div class="line">                        self.node_size+=<span class="number">1</span></div><div class="line">                        <span class="keyword">break</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>插入了之后，就可以查找节点了，查找相当简单，多亏了这是二叉排序树，你只需要从金字塔顶端往下走就行，遇上小的往左，遇上大的往右，直到碰到和自己一样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self,x)</span>:</span></div><div class="line">        current_node=self.root</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> current_node:</div><div class="line">                result=<span class="keyword">None</span></div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">elif</span> x&lt;current_node.key:</div><div class="line">                current_node=current_node.lchild</div><div class="line">            <span class="keyword">elif</span> x&gt;current_node.key:</div><div class="line">                current_node=current_node.rchild</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                result=current_node</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>呵呵，挺好的，貌似差不多了，，，不过还有删除呢。<br>删除这个操作，是二叉树里最烦的操作了。它涉及到各种情况，虽然写法不一，但思路都是一样，无外乎包含这四种情况：</p>
<ol>
<li>被删节点是叶节点（不够准确，其实是既无左子树又无右子树）</li>
<li>被删节点有左子树但没有右子树</li>
<li>被删节点有右子树但没有左子树</li>
<li>被删节点左右子树都有</li>
</ol>
<a id="more"></a>
<p>什么？还有被删节点是根节点？嗯，确实，它可以看做是1的一种特殊情况，它本身没有子节点，同时没有父节点。</p>
<p>首先理解一下前驱和后继的含义。<br>节点key的前驱，就是中序遍历时，比key小的所有节点中最大的那个节点。<br>节点key的后继，就是中序遍历时，比key小的所有节点中最大的那个节点。</p>
<p>所以，根据定义，被删节点用前驱或者后继替代都是合法的。</p>
<p>针对这四种情况，我列几张图，说明一下：</p>
<ol>
<li>既无左子树又无右子树</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/bst_1.png" alt="bst" title="">
                </div>
                <div class="image-caption">bst</div>
            </figure>
<p>这俩节点都是属于这种情况，应该直接删掉。</p>
<ol>
<li>有左子树但没有右子树</li>
</ol>
<ul>
<li>先解释一下，可以有两种做法，可以用左孩子节点替换，也可以用前驱节点替换，反正都符合二叉排序树的性质，我这里采用前驱节点替换：</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/bst_2.png" alt="bst" title="">
                </div>
                <div class="image-caption">bst</div>
            </figure>
<ol>
<li>有右子树但没有左子树</li>
</ol>
<ul>
<li>同理地，可以有两种做法，可以用右孩子直接替换，也可以用后继节点替换，我这里采用了右孩子直接替换：</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/bst_3.jpg" alt="bst" title="">
                </div>
                <div class="image-caption">bst</div>
            </figure>
<ol>
<li>既有左子树又有右子树</li>
</ol>
<ul>
<li>同样地，可以有两种做法，可以用前驱节点替换，也可以用后继节点替换，这里采用后继节点替换：</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/bst_4.png" alt="bst" title="">
                </div>
                <div class="image-caption">bst</div>
            </figure>
<p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_successor</span><span class="params">(self,x)</span>:</span></div><div class="line">        node=self.find(x)</div><div class="line">        current_node=node.rchild</div><div class="line">        <span class="keyword">while</span> current_node.lchild:</div><div class="line">            current_node=current_node.lchild</div><div class="line">        <span class="keyword">return</span> current_node</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pre</span><span class="params">(self,x)</span>:</span></div><div class="line">    node=self.find(x)</div><div class="line">    current_node=node.lchild</div><div class="line">    <span class="keyword">while</span> current_node.rchild:</div><div class="line">        current_node=current_node.rchild</div><div class="line">    <span class="keyword">return</span> current_node</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,x)</span>:</span></div><div class="line">    self.delete(x)</div><div class="line">    self.node_size-=<span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self,x)</span>:</span></div><div class="line">    node=self.find(x)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">if</span> node.lchild <span class="keyword">and</span> <span class="keyword">not</span> node.rchild:</div><div class="line">            pre=self.get_pre(node.key)</div><div class="line">            value=pre.key</div><div class="line">            self.delete(value)</div><div class="line">            node.key=value</div><div class="line">        <span class="keyword">elif</span> node.rchild <span class="keyword">and</span> <span class="keyword">not</span> node.lchild:</div><div class="line">            <span class="keyword">if</span> node.is_left_child():</div><div class="line">                node.rchild.parent=node.parent</div><div class="line">                node.parent.lchild=node.rchild</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                node.rchild.parent=node.parent</div><div class="line">                node.parent.rchild=node.rchild</div><div class="line">        <span class="keyword">elif</span> node.lchild <span class="keyword">and</span> node.rchild:</div><div class="line">            successor=self.get_successor(node.key)</div><div class="line">            value=successor.key</div><div class="line">            self.delete(value)</div><div class="line">            node.key=value</div><div class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node.lchild <span class="keyword">and</span> <span class="keyword">not</span> node.rchild:</div><div class="line">            <span class="keyword">if</span> node.is_left_child():</div><div class="line">                node.parent.lchild=<span class="keyword">None</span></div><div class="line">            <span class="keyword">elif</span> node.is_right_child():</div><div class="line">                node.parent.rchild=<span class="keyword">None</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.root=<span class="keyword">None</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError</div><div class="line">    <span class="keyword">except</span> AttributeError:</div><div class="line">        <span class="keyword">print</span> <span class="string">"The node is not in the tree"</span></div></pre></td></tr></table></figure></p>
<p>大致思路就是这样，二叉排序树就这样介绍完了。</p>
<p>来分析一波时间复杂度，按照二叉排序树的性质，只要是中序遍历，那肯定会生成一个有序序列。因为时间复杂度只与二叉树的深度有关，如果刚好这棵树的深度和节点数量一样（起始就是升序插入），那和顺序查找（时间复杂度O(n)）没有区别=。=，这就杯具了。但乐观点讲，假入这个二叉排序树初始化的特别巧妙，恰好最后变成了一颗完全二叉树，岂不妙哉（时间复杂度O(logn)）？</p>
<p>该如何确保它变成这样呢？所以有了平衡的概念，看来前人为了方便查找可谓是煞费苦心。</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>平衡二叉树是优化后的二叉排序树，在这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。<br>还是举个例子吧。</p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>AVL树，毫无疑问，典型中的典型。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p>
<p>“Wtf？平衡因子？树旋转？什么玩意儿？”</p>
<p>这么说吧，树旋转操作是把一颗普通排序树变为平衡树的核心操作，而这个操作要根据平衡因子来判断。这就跟节点删除一样，考虑的情况多，而且更加复杂。不过先不用急，慢慢来：</p>
<p>我们先来看张图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/tree_rotate.jpg" alt="bst" title="">
                </div>
                <div class="image-caption">bst</div>
            </figure>
<p>通过上面操作，树趋于平衡。究竟是什么操作？就是通过树旋转操作。</p>
<p>树旋转操作有四种情况：</p>
<ul>
<li>LL型<br>先来张图体会一下：<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/tree_rotate_ll.jpg" alt="bst" title="">
                </div>
                <div class="image-caption">bst</div>
            </figure>
</li>
</ul>
<p>可以看到，50的平衡因子超过了1，不平衡，需要调整。这是什么类型？这是在不平衡节点的左子树的左子树上发生的事情。所以，它是LL型。<br>结合上图说明，它要做的工作有两步：</p>
<ol>
<li>以50的左孩子23为中心，右旋转；</li>
<li>23的右子树被移动当作50的左子树（无右子树情况下，无需这一步）</li>
</ol>
<ul>
<li>RR型</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/tree_rotate_rr.jpg" alt="bst" title="">
                </div>
                <div class="image-caption">bst</div>
            </figure>
<p>同理地，RR型旋转要做的工作：</p>
<ol>
<li>以50的右孩子60为中心，左旋转；</li>
<li>60的左子树被移动当作50的右子树（无左子树情况下，无需这一步）</li>
</ol>
<p>LL型和RR型都还算是比较简单的。后面来俩复杂点的，先看图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/tree_rotate_2.png" alt="bst" title="">
                </div>
                <div class="image-caption">bst</div>
            </figure>
<p>这怎么搞？如果你直接右旋转的话，你会发现将不符合排序树的性质，因为32比23大了。为什么会这样呢，因为32是23的右子树啊。这事情发生在不平衡节点的左子树的右子树上，所以它叫LR型。</p>
<ul>
<li>LR型<br>接着上面的图说明，要解决LR型的旋转还是有点套路的，如果把50的左子树变形成LL型那样的就好了。是，就这样做。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/tree_rotate_lr.jpg" alt="bst" title="">
                </div>
                <div class="image-caption">bst</div>
            </figure>
<p>先解决左子树姿势不正确的问题，然后你发现可以直接右旋了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/tree_rotate_lr_2.jpg" alt="bst" title="">
                </div>
                <div class="image-caption">bst</div>
            </figure>
<ul>
<li>RL型</li>
</ul>
<p>看懂了LR型，再来看RL型，那就是如法炮制了。<br>先解决右子树姿势问题，再左旋。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/tree_rotate_rl.jpg" alt="bst" title="">
                </div>
                <div class="image-caption">bst</div>
            </figure></p>
<p>知道怎么解决平衡了。还有一个困扰的问题是，如何检测不平衡的发生，这个事情发生在插入节点甚至删除节点的时候。事实上只需检测不平衡的最小子树就行了，因为不平衡是建立在已平衡基础上的。所以只需要向上查找不平衡的节点就可以了。</p>
<p>上面的二叉排序树还派的上用场，先改造一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_balance</span><span class="params">(self,node)</span>:</span>                     <span class="comment">#判断是否平衡</span></div><div class="line">    bf=self.get_bf(node)</div><div class="line">    <span class="keyword">if</span> bf&gt;<span class="number">1</span> <span class="keyword">or</span> bf&lt;<span class="number">-1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bf</span><span class="params">(self,node)</span>:</span>                      <span class="comment">#获取一个节点的平衡因子</span></div><div class="line">    lh=self.get_node_h(node.lchild)</div><div class="line">    rh=self.get_node_h(node.rchild)</div><div class="line">    <span class="keyword">return</span> lh-rh</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_node_h</span><span class="params">(self,node)</span>:</span>                  <span class="comment">#获取一个节点的高度,这里的高度不是指节点所在的层数</span></div><div class="line">    <span class="keyword">return</span> self.get_node_h_helper(node)<span class="number">-1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_node_h_helper</span><span class="params">(self,node)</span>:</span>           <span class="comment">#获取高度的辅助函数</span></div><div class="line">    l,r=<span class="number">0</span>,<span class="number">0</span></div><div class="line">    <span class="keyword">if</span> node:</div><div class="line">        l=self.get_node_h_helper(node.lchild)</div><div class="line">        r=self.get_node_h_helper(node.rchild)</div><div class="line">    <span class="keyword">return</span> l+<span class="number">1</span> <span class="keyword">if</span> l&gt;r <span class="keyword">else</span> r+<span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>有了上面的函数，我们就可以根据是否平衡来进行树旋转操作了。（朋友们有没有更好的判断平衡的方法？）<br>下面实现四种插入的情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree_rotate_ll</span><span class="params">(self,node)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node.parent:</div><div class="line">        self.root=node.lchild</div><div class="line">        node.lchild.parent=<span class="keyword">None</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        node.lchild.parent=node.parent</div><div class="line">        <span class="keyword">if</span> node.is_left_child():</div><div class="line">            node.parent.lchild=node.lchild</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            node.parent.rchild=node.lchild</div><div class="line">    temp_node=node.lchild.rchild        <span class="comment">#记住左节点的右节点（孩子）</span></div><div class="line">    node.lchild.rchild=node</div><div class="line">    node.parent=node.lchild</div><div class="line">    <span class="keyword">if</span> temp_node:                       <span class="comment">#如果该节点不为空，则把它的父亲置为需要调整的节点</span></div><div class="line">        temp_node.parent=node</div><div class="line">    node.lchild=temp_node               <span class="comment">#需要调整的节点的左孩子设成刚刚记住的节点（孩子）</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree_rotate_rr</span><span class="params">(self,node)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node.parent:</div><div class="line">        self.root=node.rchild</div><div class="line">        node.rchild.parent=<span class="keyword">None</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        node.rchild.parent=node.parent</div><div class="line">        <span class="keyword">if</span> node.is_left_child():</div><div class="line">            node.parent.lchild=node.rchild</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            node.parent.rchild=node.rchild</div><div class="line">    temp_node=node.rchild.lchild        <span class="comment">#记住右孩子的左节点（孩子）</span></div><div class="line">    node.rchild.lchild=node</div><div class="line">    node.parent=node.rchild             </div><div class="line">    <span class="keyword">if</span> temp_node:                       <span class="comment">#节点不为空，则把它的父亲置为需要调整的节点</span></div><div class="line">        temp_node.parent=node</div><div class="line">    node.rchild=temp_node               <span class="comment">#需要调整的节点的右孩子设成刚刚记住的节点（孩子）</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree_rotate_lr</span><span class="params">(self,node)</span>:</span></div><div class="line">    node.lchild.rchild.parent=node              <span class="comment">#操作较为繁杂，仔细品味，有指针的话更好理解</span></div><div class="line">    temp_node=node.lchild.rchild.lchild         <span class="comment">#记住左孩子的右孩子的左孩子，为啥，请看图</span></div><div class="line">    node.lchild.rchild.lchild=node.lchild       </div><div class="line">    node.lchild=node.lchild.rchild</div><div class="line">    node.lchild.lchild.rchild=<span class="keyword">None</span>              <span class="comment">#先置空</span></div><div class="line">    node.lchild.lchild.parent=node.lchild</div><div class="line">    <span class="keyword">if</span> temp_node:</div><div class="line">        temp_node.parent=node.lchild.lchild</div><div class="line">        node.lchild.lchild.rchild=temp_node     <span class="comment">#赋给左孩子的左孩子的右孩子</span></div><div class="line">    self.tree_rotate_ll(node)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree_rotate_rl</span><span class="params">(self,node)</span>:</span></div><div class="line">    node.rchild.lchild.parent=node</div><div class="line">    temp_node=node.rchild.lchild.rchild         <span class="comment">#记住右孩子的左孩子的右孩子</span></div><div class="line">    node.rchild.lchild.rchild=node.rchild</div><div class="line">    node.rchild=node.rchild.lchild</div><div class="line">    node.rchild.rchild.lchild=<span class="keyword">None</span>              <span class="comment">#先置空</span></div><div class="line">    node.rchild.rchild.parent=node.rchild</div><div class="line">    <span class="keyword">if</span> temp_node:</div><div class="line">        temp_node.parent=node.rchild.rchild</div><div class="line">        node.rchild.rchild.lchild=temp_node     <span class="comment">#赋给右孩子的右孩子的左孩子</span></div><div class="line">    self.tree_rotate_rr(node)</div></pre></td></tr></table></figure>
<p>这样，四种类型的旋转也完成了（在码这四种操作的时候头有点晕=。=），好像差不多了。但事实还有一步，就是如何知道不平衡时采用哪种旋转，我看了很多博客，几乎都没有提到这一点。也许是觉得太简单了，略过了=。=<br>所以，在这里再分析一下旋转类型的判断,具体看代码注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_imbanlance</span><span class="params">(self,node)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.is_balance(node):</div><div class="line">        <span class="keyword">if</span> self.get_bf(node)&gt;<span class="number">1</span>:                    <span class="comment">#如果平衡因子大于1，那肯定是LL或者LR</span></div><div class="line">            <span class="keyword">if</span> self.get_node_h(node.lchild.lchild)&gt;self.get_node_h  (node.lchild.rchild):               <span class="comment">#左子树的左子树高度大于左子树的右子树，可以判定为LL</span></div><div class="line">                self.tree_rotate_ll(node)</div><div class="line">            <span class="keyword">else</span>:                               <span class="comment">#小于则为LR</span></div><div class="line">                self.tree_rotate_lr(node)</div><div class="line">        <span class="keyword">else</span>:                                       <span class="comment">#平衡因子小于1，那肯定是RR或者RL</span></div><div class="line">            <span class="keyword">if</span> self.get_node_h(node.rchild.rchild)&gt;self.get_node_h(node.rchild.lchild):                <span class="comment">#右子树的右子树高度大于右子树的左子树，可以判定为RR</span></div><div class="line">                self.tree_rotate_rr(node)</div><div class="line">            <span class="keyword">else</span>:                               <span class="comment">#小于则为RL</span></div><div class="line">                self.tree_rotate_rl(node)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>实力分析一波：<br>只有在插入和删除的时候，才会出现不平衡。一切都建立在二叉查找树的插入和删除操作上。</p>
<ul>
<li>插入<br>插入的时候，因为整棵树事先是平衡的，所以只需要往上查找不平衡的节点就行，然后根据类型执行旋转操作。</li>
</ul>
<p>插入还好，最多也就两次旋转。因为插入的时候，只根据某一个节点进行调整。</p>
<ul>
<li>删除<br>删除就不一样了,先按照普通的BST进行删除，而这个时候就需要进行平衡检查，怎么个检查法？插入的时候，好歹节点是插进来的，可以根据它往上查找，但删除节点后，节点都不存在了，怎么检查呢？</li>
</ul>
<p>可以明确的一点是：<br>假如一个节点被删除，那替代它之后的节点以及往上的父啊祖啊什么的节点，平衡因子都可能发生变化。<br>“嘿嘿，难道不是像插入那样，找到第一个不平衡的然后调整完不就得了？”</p>
<p>其实，你在找到第一个不平衡的节点调整完之后，只是局部调整好了。来张图你就懂了：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/avl_delete_1.jpg" alt="avl" title="">
                </div>
                <div class="image-caption">avl</div>
            </figure></p>
<p>然后你调整完之后，变成了这样<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/avl_delete_2.jpg" alt="avl" title="">
                </div>
                <div class="image-caption">avl</div>
            </figure></p>
<p>“本来就应该这样，这不很好吗？”</p>
<p>但是你发现这所谓局部的子树，高度已经发生了变化，由5变成了4。<br>你想一下，要是它的爸爸的另一个孩子，也就是它兄弟那边，高度是6（按照定义符合AVL树），造成了爸爸的平衡因子超过2，这可咋整？然后你又要调。<br>更糟糕的是，调完后又发现爷爷又不平衡了，所以继续。。。如此，直到根节点（这是最坏情况）。</p>
<p>所以，删除对于AVL树来说是一个糟心的过程。而且，删除一个节点很容易就造成整棵树的不平衡，造成调整多次。</p>
<p>由此，在原来BST的基础上，添加调整平衡的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#插入</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,x)</span>:</span></div><div class="line">    self.insert_helper(x)</div><div class="line">    node=self.find(x)</div><div class="line">    self.check_imbanlance(node)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#删除</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,x)</span>:</span></div><div class="line">    node=self.find(x)</div><div class="line">    self.delete(node)</div><div class="line">    need_to_check_balance=node          <span class="comment">#先保存当前节点</span></div><div class="line">    <span class="keyword">while</span> need_to_check_balance:        </div><div class="line">        temp_parent=need_to_check_balance.parent        <span class="comment">#向上不断检查</span></div><div class="line">        self.check_imbanlance(need_to_check_balance)</div><div class="line">        need_to_check_balance=temp_parent</div><div class="line">    self.node_size-=<span class="number">1</span></div></pre></td></tr></table></figure>
<p>终于把AVL树一步一步给实现了，长舒一口气。感觉AVL树已经让你很疲倦了，但是，红黑树还没有开始。</p>
<p>为什么要有红黑树？AVL树跟红黑树比差哪了？</p>
<p><strong>刚才在AVL树中，已经看到AVL树的删除操作在最坏情况下，调整的次数是O(logn)</strong></p>
<p>AVL树在红黑树面前，几乎就是小巫见大巫，做好心理准备吧，见识见识这真正变态级的数据结构：</p>
<h2 id="再遇红黑树"><a href="#再遇红黑树" class="headerlink" title="再遇红黑树"></a>再遇红黑树</h2><p>就像练了级回来再次挑战一样，我想这次已经有了足够了的资本。</p>
<h3 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h3><ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p>红黑树为什么变态？<br>因为你就算埋头看个几天，甚至都没搞清楚它，即使你记下了步骤，依然不知所以。看红黑树，就是硬着头皮看的。</p>
<p>所以，为了避免懵逼。还是先入手一下2-3树或者2-3-4树。</p>
<p>“怎么还不讲红黑树，之前就已经绕过一次了，这是要干嘛？”</p>
<p>没办法，直接讲红黑树，就算看懂了，很快就忘了，因为你根本不知道它的意义。它究竟为谁而生？</p>
<h2 id="2-3Tree"><a href="#2-3Tree" class="headerlink" title="2-3Tree"></a>2-3Tree</h2><p>2-3树对于人类思维来讲非常好理解（表骗我）。你先别问2-3树的好处是啥，它在我这里，只是理解红黑树的一个工具。<br>注意，它不是二叉树了，但它是二叉排序树的一种泛化版。它由2-节点跟3-节点构成。</p>
<ul>
<li>定义： </li>
</ul>
<ol>
<li>要么空，要么就是这样：</li>
<li>对于2-node，它有一个键值key，和两个子节点（左、右）。左节点是一个2-3节点，它里面的元素都比key要小；右节点也是一个2-3节点，它里面的元素都比key要大。</li>
<li>对于3-node，它有两个键值A和B，以及三个子节点（左、中、右）。左节点是一个2-3节点，它的元素比A都要小；中节点是一个2-3节点，它的元素的值介于A和B之间；右节点也是一个2-3节点，它的元素比B都要大。</li>
</ol>
<p>叶节点的孩子节点为空（null links）。</p>
<p>直接上《算法》里的图：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_1.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure></p>
<p>一颗完美的2-3树，它到所有null links的距离都是一样的。</p>
<p>诶，我们要讲就要讲完美的，其他的不谈。</p>
<h3 id="2-3Tree查找"><a href="#2-3Tree查找" class="headerlink" title="2-3Tree查找"></a>2-3Tree查找</h3><p>查找就不用说了吧？跟BST是一个道理，从祖宗开始往下查，有则有，无则无。<br>《算法》里的图很形象：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_2.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure></p>
<h3 id="2-3Tree插入"><a href="#2-3Tree插入" class="headerlink" title="2-3Tree插入"></a>2-3Tree插入</h3><p>套路都差不多了，插入都是基于查找。</p>
<ul>
<li>往2-node里插</li>
</ul>
<p>如果插入一个节点时，查询刚好终止于一个2-node，那么很幸运，这个很好操作，只需要将这个2-node变成一个3-node即可：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_3.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure>
<ul>
<li>往3-node里插</li>
</ul>
<p>但是往3-node里面插入节点就没那么友好了，可以说，相当复杂：</p>
<ul>
<li>插入的3-node是一个由独立的3-node所构成的树<br>这个还相对简单点，先把它变成一个暂时的4-node：</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_4.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure>
<p>然后分割这个4-node，中间那个推上去，把这个4-node变成一颗2-3树：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_5.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure></p>
<ul>
<li>插入的3-node的父节点是一个2-node</li>
</ul>
<p>第一步，还是先把它变成一个暂时的4-node：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_6.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure>
<p>然后，分割这个4-node，把中间那个推上去：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_7.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure></p>
<ul>
<li>插入的3-node的父节点是一个3-node</li>
</ul>
<p>第一步，把它变成一个4-node：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_8.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure></p>
<p>然后，分割，推中：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_9.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure></p>
<p>然后你发现，这一推，父节点也变成4-node了。咋办？那就继续推中：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_10.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure>
<ul>
<li>根节点是4-node</li>
</ul>
<p>推中推的很爽，结果发现王座变成了4-node。其实这个跟上种情况一样，继续推中，推出一个新的根节点：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_11.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure>
<p>所以，在插入元素到3-node的时候，暂时生成的4-node“推中”是一个有讲究的操作。总结一下“推中”到底能遇上哪些情况：</p>
<ul>
<li><p>根节点“推中”</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_12.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure>
</li>
<li><p>“推中”的对象是2-node<br>有两种情况：</p>
</li>
</ul>
<ol>
<li>4-node是2-node的左子树，这个推到2-node左边；</li>
<li>4-node是2-node的右子树，这个推到2-node右边；</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_13.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure>
<ul>
<li>“推中”的对象是3-node<br>有三种情况：</li>
</ul>
<ol>
<li>4-node是3-node的左子树，这个推到3-node左边；</li>
<li>4-node是3-node的中子树，这个推到3-node中间；</li>
<li>4-node是3-node的右子树，这个推到3-node右边；</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2-3_tree_14.png" alt="2-3_tree" title="">
                </div>
                <div class="image-caption">2-3_tree</div>
            </figure>
<p>看完上面的东西，有什么值得注意的吗？<br><strong>可以知道，2-3树在单纯插入的时候高度是不会变的，变是变在“推中”的操作上。而且，它时刻都在保持着完美平衡。因为它完美平衡，所以插入操作始终发生在底部。</strong><br>完美平衡的好处之一就是查找快。这不用说了吧？<br>“AVL也快啊~~”<br>是，我之前说什么来着，AVL它删除可能会很耗时，旋转太多！2-3树一看上去都不用旋转，是不是6翻了？<br>那好吧，就来实现实现。<br>根据以上的规则，可以写出一堆代码出来，它对代码实现不是很友好。你可能觉得挺简单的，但事实上，涉及到了两种节点，在考虑情况的时候就很头疼。能不能只靠一种节点来实现，不要这些什么2-节点、3-节点，甚至4-节点的，写出来就感觉麻烦。</p>
<h2 id="2-3树到红黑树"><a href="#2-3树到红黑树" class="headerlink" title="2-3树到红黑树"></a>2-3树到红黑树</h2><p>终于到了红黑树了，这次不会再绕弯了。</p>
<p>其实，看完这些，估计心里就有些想法了，红黑树该不会是2-3树进化过来的吧？<br>呃，这谈不上是进化，只能说红黑树是单纯的二叉树实现了2-3树。</p>
<p>“逗我呢，这哪是二叉？那开三叉的3-节点怎么搞？”</p>
<p>对，我要说的就是3-节点要怎么搞，我们要对3-节点进行一下处理，《算法》书上说叫对3-节点进行编码。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_1.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>如同书上所说，一个3-node，它变成了两个2-node。<strong>之前的3-node的左元素被抽离出来，变成了3-node的右元素的左节点。</strong>并且这两个2-node由红线相连。把2-3树里的所有3-node都变成这样，就成了一个红黑树的雏形。为什么只是雏形？因为描述边的特点没有描述节点来的方便。我们加点料看看。</p>
<p>理解刚才那句<strong>“3-node的左元素被抽离出来，变成了3-node的右元素的左节点”</strong>是很重要的。根据书上描述，这里要定义3-node的右元素为h节点：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_2.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>并且，还有两件重要的事，直接说明了红、黑节点究竟是怎么着色的：</p>
<ol>
<li>h节点的左节点为红节点；</li>
<li>h节点的右节点为黑节点；<br>此外，空链接根据约定，也为黑节点。</li>
</ol>
<p>怎么样？总算知道了吧？红黑树的红与黑不是在变戏法（有些同志像介绍戏法一样介绍红黑树，怎么看得懂？），它只是约定俗成而已。<br>再来看看红黑树的五条性质：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p>1、3都不必说了（第二条性质待会儿再说）。其实，有些人好奇就好奇在为什么有4、5这样的性质。现在，就给你分析一波：</p>
<ul>
<li><p>为啥不能有两个连续的红色节点？<br>如刚才的图，h节点是3-节点的右元素，只有3-节点的左元素才有变成红节点的条件；如果h节点也想变红，除非它还有个兄弟在它右边，但是如果它还有右兄弟的话，那这个节点就不是3-节点，而是4-节点了（注意这里的描述，h节点不是不可以变红，只是它暂时会变红，就跟2-3树里会有临时的4-node一样）。</p>
</li>
<li><p>为啥所有路径上的黑色节点数量一样？<br>先想一下2-3树，它到所有叶节点的距离都是一样的。再想想红节点是怎么出来的？红节点是3-节点的左元素分离出来的，并且用红线跟h节点相连。对于2-3树来说，红线是不是多余的东西？剩下的自然就都是黑线了啊，红线和红节点在2-3树这个层面上来说，影响不到2-3树的高度。可能说的有点不明白，那下图绝对能让你明白：</p>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_3.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>那么接下来，就是红黑树的神级操作。唯一会让你困扰的是，红黑树在处理插入3-node（相对于等价的2-3树）的时候，不是采取“推中”的策略，而是“分裂”的策略（从这里的理解开始，我跟《算法》里的描述可能有些许不一样，但总归来讲思想还是一样的）。</p>
<p>我要引导的是，如何从2-3树的概念里转换过来：<br>依然像2-3树那样进行插入操作。所以，在下面的描述里，关于2-node，3-node，4-node这些，只是红黑树里等价于对应2-3树的说法。</p>
<h3 id="树旋转操作"><a href="#树旋转操作" class="headerlink" title="树旋转操作"></a>树旋转操作</h3><p>介绍红黑树的插入之前，我想先介绍一下树旋转。但是为了更好地理解，先来个插入操作作为引子。</p>
<h4 id="往独立的2-node里面插（只有root节点）"><a href="#往独立的2-node里面插（只有root节点）" class="headerlink" title="往独立的2-node里面插（只有root节点）"></a>往独立的2-node里面插（只有root节点）</h4><p>2-3树的2-node：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_4.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure><br>红黑树的2-node：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_5.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure></p>
<ul>
<li><p>插入一个相对于b小的元素a：<br>2-3树：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_6.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>红黑树：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_7.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>这一步，显然，对照一下2-3树，2-3树的2-node变成了3-node，而3-node显然要编码成红黑树的标准。b成为所谓的h节点，a作为它的左节点，当然也就是红线相连，并且a节点标成红色。</p>
</li>
<li><p>插入一个相对于b大的元素c:<br>2-3树：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_8.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>红黑树：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_9.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>“嘿嘿嘿，你怎么乱搞？”<br>这不是乱搞，首先，我们得按照二叉排序树的规定来插入节点。<br>“插入就插入，为啥把它搞成红的？不是说只有左元素才有这个条件吗？”<br>红的是因为要符合红黑树的第五条性质。<br>“那不矛盾了？”<br>先别急，我还得旋转它呢：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_10.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
</li>
</ul>
<p><strong>明确一点，红黑树的插入操作还是按照二叉排序树的套路来（不然之前复习过的都白费了不是吗=。=），默认插入的节点是红节点。产生冲突了（和红黑树定义违背）再进行树旋转和变色操作。</strong></p>
<p>上面的例子里，就出现了需要调整的情况，《算法》上总结了两种旋转操作：</p>
<ul>
<li>左旋转<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_11.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure></li>
<li><p>右旋转</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_12.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>“为什么还会有右旋转？对啊，我也想问。这不是把本来正确的给整成错的了吗？”</p>
</li>
<li><p>变色<br>呵呵，上面我已经说过，那个所谓的h节点不是不可以变红，当它是4-node的中间节点是，它会是红的，所以这个右旋转其实是起到一个过渡作用，看下面的情况：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_14.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>你看，我想插入a（b已经红了），那它就得在b左边，形成一个临时的4-node，而对于临时的4-node，是需要“推中”的，在红黑树里，其实就是LL旋转（b为中心）：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_15.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
</li>
</ul>
<p>“这下左右都是红的了，还搞毛。。。”<br>忘了4-node怎么拆分的了吗？，把b节点推上去，4-node变成3个2-node，放在红黑树的概念里，自然也就没有所谓的红节点了：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_16.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure><br>注意图中的最后一步，我把b节点变红了。你应该可以理解，因为中间状态的时候，这个子树的黑色层级变高了，不符合红黑树的第五条性质。</p>
<p><strong>但是，在b节点是根节点的情况下，不能变色，而且你即使翻转它的颜色，也是个多余动作。</strong>根节点是红或黑，都影响不到红黑树的第五条性质。而且，你可以想一下，根节点如果设成红色，就没法往下进行了。所以，<strong>保持根节点是黑色的</strong>。这也就是红黑树为什么有第二条性质。</p>
<p>“b不是根节点的话，如果b节点本身是左边的子节点还好，如果是右边的子节点，又得左旋转。”<br>嗯，是的。这里的插入操作，有时候需要多次旋转，最多三次旋转。<br>至于这些旋转操作，前面已经介绍过AVL树的旋转操作，所以这里不再重复介绍（就多了根红线嘛。。看前面的LL、LR、RR、RL去）</p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>上面已经提到过一种插入操作，下面继续，要知道，红黑树的插入除了发生在根节点，就是在叶节点了。</p>
<h4 id="往底部的2-node插入"><a href="#往底部的2-node插入" class="headerlink" title="往底部的2-node插入"></a>往底部的2-node插入</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_13.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>和在根节点插入差不多，只不过有父节点存在而已。</p>
<p>下面，往3-node里面插入，和2-3树一样，很多种情况：</p>
<h4 id="一个单独的3-node"><a href="#一个单独的3-node" class="headerlink" title="一个单独的3-node"></a>一个单独的3-node</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_18.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<h4 id="往底部的3-node插入"><a href="#往底部的3-node插入" class="headerlink" title="往底部的3-node插入"></a>往底部的3-node插入</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_17.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>有时候旋转最多要三次，就是如下这种情况（为啥不是两次？两次也是对的，马上就讲）：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_19.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure></p>
<p>好了，我算是把《算法》上的2-3树到红黑树基本复述了一遍。<br>“诶，貌似没讲完，还有删除操作呢？”</p>
<p>先打断一下，你可能会发现，2-3树概念里的红黑树，虽然处处符合红黑树的5条性质，但总感觉不够。而且你如果之前看过其他的博客，你会发现跟大多数讲的不一样，你肯定会提出质疑：<br>上面实现的红黑树，如果节点没有左子树，往右边插入，就一定会调整到左边，因为它不符合所谓的red link（2-3树）定义。但事实上，红节点在右边又怎么了？没毛病啊，根本不会违背红黑树的性质。红色节点通通都是左节点，强行左转右的操作让你很不爽。<br>所以，你觉得这可能是劣化版的红黑树。</p>
<p>我当然知道你在想什么，2-3-4树，对不对？是的，2-3-4树才是红黑树的对应版本，为什么不早点说？其实本质是一样的，所以，这里就是个玄学问题（笑）。区别在4-node，看下图：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_20.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure><br><strong>关键是你怎么看待4-node，2-3树里也会有4-node，只不过它是暂时存在的，“推中”是它的核心操作；对于2-3-4树来说，又是怎样一副景象呢？在遇上4-node的时候，难道还要生成一个临时的5-node吗？并不是，在这个时候，它需要先“分裂”成3个2-node（其实就是2-3树的“推中”）。所以，一切取决于你是选择他“推中”还是“分裂”，英文原话叫“bottom-up 2-3”跟“top-down 2-3-4”。</strong></p>
<p>事实上，我讲的这个版本的红黑树，它不是劣化版本，反而更加高级。它是红黑树的发明人之一Robert Sedgewick先生为了减少原有红黑树插入/删除需要处理的情况数量，自己改进的算法，它叫<code>Left-leaning red-black trees</code>（LLRBT），即左偏红黑树。在它的世界里，红节点就是要左倾的。它比起一般的RBT，有以下优点：</p>
<ul>
<li>它可以与2-3-4树保持完美的一一对应</li>
<li>它可以保持完美的黑链平衡</li>
</ul>
<p>我在这里稍微提一提2-3-4树吧，2-3-4树允许树中有这样的节点：</p>
<ul>
<li>2-node：一个key，2个孩子</li>
<li>3-node：两个key，3个孩子</li>
<li>4-node：三个key，4个孩子<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_23.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
</li>
</ul>
<p>普通RBT编码方式：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_21.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure><br>3-node的编码方式跟刚才不一样了，红线可以在左，可以在右。4-node作为合法存在，它的两个子节点都可为红。</p>
<p>LLRBT编码方式：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_25.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure><br>3-node的编码方式就是我上面讲的，它不允许红节点存在于右边。而关于4-node，你可以看上面讲的变色操作。所以，你明白了，我其实一直在讲的就是这个LLRBT。</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>插入都这么艰难了，删除岂不更加费脑？红黑树的删除包含集中操作？我不会分析那些什么父黑叔红，父红叔红各种情况的，那样只会让人眼花缭乱。明明都讲了2-3树，还要各种记红啊黑什么的，那我讲2-3树有何用？</p>
<p>在LLRBT里，删除一个节点，比插入还简单，我在这里提供一个策略：</p>
<ol>
<li>找到被删节点的后继节点</li>
<li>后继节点的key替换被删节点的key</li>
<li>删除后继节点</li>
</ol>
<p>套路听上去跟普通的BST差不多，没错，就是一样，删一个节点，就是找到后继节点，把key替换掉，然后删掉后继节点。只不过你要进行变色而已。晕~~</p>
<p>明确一点，<strong>删除一个红节点不会影响到红黑树的性质。</strong>不是吗？<br>“那我删的后继节点就是黑的怎么办？”<br>“把它变成红的。”</p>
<p>黑的是啥？黑的在2-3树里就是2-node，普通节点。红的是啥？红的存在于2-3树里的3-node，也可以暂时存在于4-node。如果我删的是黑节点，也就是2-node，那我就要想办法把它变成4-node来进行删除。</p>
<p>“WTF？黑的变红的很容易啊，三个黑的组一块，变成一个4-node不就完了？”</p>
<p>是啊，我就是要利用临时的4-node。不过，你还需要考虑，你是从别的层级借过来黑节点，这意味着，这颗子树的黑链长度遭到改变，有可能就破坏了整棵树的黑链平衡。我事先想强调的一点是，对于普通的红黑树，3-node的编码，左红或者右红都是没什么区别的，这一点影响不到红黑树的第五条性质。我们同样可以利用这一点。</p>
<p>“噢，那要怎么做？”</p>
<p>所以，意思就是利用同构的特点以及暂时的4-node对二叉树进行旋转加变色，但要始终保持黑链平衡。</p>
<p>先看图，之后再解释：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_27.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>假如我要删掉这颗树（或者只是颗子树）的最小节点a，就从它的根节点开始往下逐层“加红”（其实就是利用暂时的4-node不断往下迁移），这样做是为了先保持黑链平衡，满足红黑树的第五条性质。等删掉之后，再通过旋转恢复成LLRBT的样子。</p>
<p>“哪有你这么理想，你这例子全是黑节点啊”</p>
<p>确实，情况还是有好几种的。</p>
<p>什么时候需要加红（变成临时的4-node）？在寻找后继节点的道路上，得分两种情况讨论。</p>
<p>先提个醒，在删除后继节点的时候，肯定是这种形态：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_31.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>完美删除，丝毫不影响红黑树的性质。</p>
<h4 id="查找路线在左子树"><a href="#查找路线在左子树" class="headerlink" title="查找路线在左子树"></a>查找路线在左子树</h4><p>也就是查找时，判断在左子树，需要“左拐”。</p>
<ul>
<li>情况一</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_30.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>到达R节点时，因为查找的节点比R小，所以要左拐，但是看到E是红的，这种情况下，就不需要加红了嘛。直接往下走就行。</p>
<ul>
<li>情况二</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_29.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>查找依然往左拐，但是看到C是黑的，如果此时直接对C动手，E的黑链就崩坏了，所以要它进行“加红”，公平起见，C和S都要变红。</p>
<ul>
<li>情况三</li>
</ul>
<p>情况三比情况二复杂点：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_32.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>就是在给S变红时，S的左儿子是红的，这种情况跟插入时情况很像，只能旋转解决。</p>
<h4 id="查找路线在右子树"><a href="#查找路线在右子树" class="headerlink" title="查找路线在右子树"></a>查找路线在右子树</h4><p>可能拐着拐着，发现要往右子树拐了：</p>
<ul>
<li>情况一</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_28.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>按照LLRBT的道理，右节点可能为红吗？反正先不管，先把R的两儿子都变红了再说。但偏偏遇上左节点已经红了，你说把右节点变红吧，黑链又崩坏了。所以就是这种情况，而且发生在根节点上，只需把它左红转换成右红，这样做依然不影响红黑树的性质。</p>
<ul>
<li>情况二</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_33.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>这种简单，直接变色就行。</p>
<ul>
<li>情况三</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/rbt_34.jpg" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
<p>这种情况就是你发现当把E的左节点C变红了之后，C的左节点A居然是红的，这一变彻底违反红黑树性质，又得调，旋转，再变色。</p>
<p>总之，删除中所需要的临时形态就是这么多了，千万记住一点，临时操作虽说是临时，也不是LLRBT的形态，但也不能违背红黑树性质。失去了LLRBT的形态不要紧，只要你熟悉插入操作，那些什么右红变左红，4-node的“推中”，不是分分钟的事嘛。</p>
<p>最后，还是来份完整代码吧，也是根据《算法》的程序，写了个python版的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,k,v,c=RED,l=None,r=None)</span>:</span></div><div class="line">        self.lchild=l</div><div class="line">        self.rchild=r</div><div class="line">        self.key=k</div><div class="line">        self.color=c</div><div class="line">        self.value=v</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Red_black_tree</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.root=<span class="keyword">None</span></div><div class="line">        self.node_size=<span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_red</span><span class="params">(self,node)</span>:</span></div><div class="line">        <span class="keyword">if</span> node:</div><div class="line">            <span class="keyword">return</span> node.color</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,k,v)</span>:</span></div><div class="line">        node=self.root</div><div class="line">        self.root=self.insert(node,k,v)</div><div class="line">        self.root.color=BLACK</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,k)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.search(self.root,k)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,node,k,v)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</div><div class="line">            <span class="keyword">return</span> Node(k,v)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> k==node.key:</div><div class="line">            node.value=v</div><div class="line">        <span class="keyword">elif</span> k&lt;node.key:</div><div class="line">            node.lchild=self.insert(node.lchild,k,v)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            node.rchild=self.insert(node.rchild,k,v)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(self.is_red(node.rchild)):           <span class="comment">#右红变左红</span></div><div class="line">            node=self.rotateLeft(node)</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(self.is_red(node.lchild) <span class="keyword">and</span> self.is_red(node.lchild.lchild)):   <span class="comment">#连续左红就要右转</span></div><div class="line">            node=self.rotateRight(node)</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(self.is_red(node.lchild) <span class="keyword">and</span> self.is_red(node.rchild)):  <span class="comment">#两孩子都红，需要翻转颜色</span></div><div class="line">            self.colorFlip(node)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> node</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,node,x)</span>:</span></div><div class="line">        current_node=node</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> current_node:</div><div class="line">                result=<span class="keyword">None</span></div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">elif</span> x&lt;current_node.key:</div><div class="line">                current_node=current_node.lchild</div><div class="line">            <span class="keyword">elif</span> x&gt;current_node.key:</div><div class="line">                current_node=current_node.rchild</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                result=current_node</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="keyword">if</span> result:</div><div class="line">            <span class="keyword">return</span> result.value</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateLeft</span><span class="params">(self,h)</span>:</span></div><div class="line">        node=h.rchild</div><div class="line">        h.rchild=node.lchild</div><div class="line">        node.lchild=h</div><div class="line">        node.color=node.lchild.color</div><div class="line">        node.lchild.color=RED</div><div class="line">        <span class="keyword">return</span> node</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self,h)</span>:</span></div><div class="line">        node=h.lchild</div><div class="line">        h.lchild=node.rchild</div><div class="line">        node.rchild=h</div><div class="line">        node.color=node.rchild.color</div><div class="line">        node.rchild.color=RED</div><div class="line">        <span class="keyword">return</span> node</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">colorFlip</span><span class="params">(self,h)</span>:</span>  <span class="comment">#翻转颜色函数</span></div><div class="line">        h.color= <span class="keyword">not</span> h.color</div><div class="line">        h.lchild.color=<span class="keyword">not</span> h.lchild.color</div><div class="line">        h.rchild.color=<span class="keyword">not</span> h.rchild.color</div><div class="line">        <span class="keyword">return</span> h</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fixUp</span><span class="params">(self,h)</span>:</span>      <span class="comment">#删除时，用到的往上修复的函数</span></div><div class="line">        <span class="keyword">if</span> self.is_red(h.rchild):</div><div class="line">            h=self.rotateLeft(h)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> self.is_red(h.lchild) <span class="keyword">and</span> self.is_red(h.lchild.lchild):</div><div class="line">            h=self.rotateRight(h)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> self.is_red(h.lchild) <span class="keyword">and</span> self.is_red(h.rchild):</div><div class="line">            h=self.colorFlip(h)</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> h</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveRedRight</span><span class="params">(self,h)</span>:</span>   <span class="comment">#删除时右路查询的情况</span></div><div class="line">        self.colorFlip(h)</div><div class="line">        <span class="keyword">if</span> self.is_red(h.lchild.lchild):</div><div class="line">            h=self.rotateRight(h)</div><div class="line">            self.colorFlip(h)</div><div class="line">        <span class="keyword">return</span> h</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveRedLeft</span><span class="params">(self,h)</span>:</span>    <span class="comment">#删除时左路查询的情况</span></div><div class="line">        self.colorFlip(h)</div><div class="line">        <span class="keyword">if</span> self.is_red(h.rchild.lchild):</div><div class="line">            h.rchild=self.rotateRight(h.rchild)</div><div class="line">            h=self.rotateLeft(h)</div><div class="line">            self.colorFlip(h)</div><div class="line">        <span class="keyword">return</span> h</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteMin</span><span class="params">(self,h)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> h.lchild:           <span class="comment">##为何，因为不可能出现黑节点在右而左节点为空的情况。而在LLRBT里，红节点一直在左</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> self.is_red(h.lchild) <span class="keyword">and</span> self.is_red(h.lchild.lchild):</div><div class="line">            h=self.moveRedLeft(h)</div><div class="line"></div><div class="line">        h.lchild=self.deleteMin(h.lchild)</div><div class="line">        <span class="keyword">return</span> self.fixUp(h)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,k)</span>:</span></div><div class="line">        self.root = self.delete(self.root, k)</div><div class="line">        self.root.color = BLACK</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self,h,k)</span>:</span></div><div class="line">        <span class="keyword">if</span> k&lt;h.key:</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">not</span> self.is_red(h.lchild) <span class="keyword">and</span> <span class="keyword">not</span> self.is_red(h.lchild.lchild)):</div><div class="line">                h=self.moveRedLeft(h)</div><div class="line">            h.lchild=self.delete(h.lchild,k)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> self.is_red(h.lchild):</div><div class="line">                h=self.rotateRight(h)</div><div class="line">            <span class="keyword">if</span> k==h.key <span class="keyword">and</span> h.rchild==<span class="keyword">None</span>:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.is_red(h.rchild) <span class="keyword">and</span> <span class="keyword">not</span> self.is_red(h.rchild.lchild):</div><div class="line">                h=self.moveRedRight(h)</div><div class="line">            <span class="keyword">if</span> k==h.key:</div><div class="line">                h.key=self.min(h.rchild)</div><div class="line">                h.value=self.search(h.rchild,h.key)</div><div class="line">                h.rchild=self.deleteMin(h.rchild)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                h.rchild=self.delete(h.rchild,k)</div><div class="line">        <span class="keyword">return</span> self.fixUp(h)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span>      <span class="comment">#查询最小节点</span></div><div class="line">        <span class="keyword">if</span> (self.root == <span class="keyword">None</span>): </div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        <span class="keyword">else</span>:              </div><div class="line">            <span class="keyword">return</span> min(self.root)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self, x)</span>:</span>   <span class="comment">#查询某子树的最小节点</span></div><div class="line">        <span class="keyword">if</span> (x.lchild == <span class="keyword">None</span>): </div><div class="line">            <span class="keyword">return</span> x.key</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> self.min(x.lchild)</div></pre></td></tr></table></figure>
<p>可能想比一下AVL跟LLRBT的性能，那就pk一下，因为实现的有差异，可能不是很客观，仅供娱乐。</p>
<ul>
<li><p>随机300个数据：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/a_r_pk_300.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
</li>
<li><p>随机3000个数据：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/a_r_pk_3000.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
</li>
<li><p>随机30000个数据：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/a_r_pk_30000.png" alt="rbt" title="">
                </div>
                <div class="image-caption">rbt</div>
            </figure>
</li>
</ul>
<p>结果LLRBT竟然遭到无情暴击。。。看来还有待优化。到这里，有关红黑树的知识就介绍完了。</p>

        <a href="/2017/06/25/红黑树/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-LRU cache的简单实现"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2017-06-25 15:54:07" datetime="2017-06-25T07:54:07.000Z"  itemprop="datePublished">2017-06-25</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/算法/">算法</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2017/06/25/LRU cache的简单实现/">LRU cache的简单实现</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    <!-- 
        LRU是什么说白了就是一种替换策略，在固定容量的缓存中，当存储满了的时候，新的数据插入，该采用何种策略，LRU就是其中一种，LRU(least recently used)，顾名思义就是最近最少使用。当新的插入时，我们要把最近最少使用的给从缓存里拿掉。
实现思路链表+哈希表
java中可以使用LinkedHashMap来实现，但我这里只给个简单的实现。
1234567891011121314...
     -->

    <h2 id="LRU是什么"><a href="#LRU是什么" class="headerlink" title="LRU是什么"></a>LRU是什么</h2><p>说白了就是一种替换策略，在固定容量的缓存中，当存储满了的时候，新的数据插入，该采用何种策略，LRU就是其中一种，LRU(least recently used)，顾名思义就是最近最少使用。当新的插入时，我们要把最近最少使用的给从缓存里拿掉。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>链表+哈希表</p>
<p>java中可以使用LinkedHashMap来实现，但我这里只给个简单的实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.pre=<span class="keyword">None</span></div><div class="line">        self.next=<span class="keyword">None</span></div><div class="line">        self.key=<span class="keyword">None</span></div><div class="line">        self.value=<span class="keyword">None</span></div><div class="line">        </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        :type capacity: int</span></div><div class="line"><span class="string">        """</span></div><div class="line">        self.cache=&#123;&#125;</div><div class="line">        self.volume=capacity</div><div class="line">        self.head=Node()</div><div class="line">        self.tail=Node()</div><div class="line">        self.head.next=self.tail</div><div class="line">        self.tail.pre=self.head</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        :type key: int</span></div><div class="line"><span class="string">        :rtype: int</span></div><div class="line"><span class="string">        """</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            node=self.cache[key]</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        node.pre.next=node.next</div><div class="line">        node.next.pre=node.pre</div><div class="line">        self.insertNode(node)</div><div class="line">        <span class="keyword">return</span> node.value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        :type key: int</span></div><div class="line"><span class="string">        :type value: int</span></div><div class="line"><span class="string">        :rtype: void</span></div><div class="line"><span class="string">        """</span></div><div class="line">        node=self.cache.get(key)</div><div class="line">        <span class="keyword">if</span> node:</div><div class="line">            self.deleteNode(node)</div><div class="line">        node=Node()</div><div class="line">        node.key=key</div><div class="line">        node.value=value</div><div class="line">        self.insertNode(node)</div><div class="line">        self.cache[key]=node</div><div class="line">        <span class="keyword">if</span> len(self.cache)&gt;self.volume:</div><div class="line">            self.deleteNode(self.head.next)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self,node)</span>:</span></div><div class="line">        node.pre.next=node.next</div><div class="line">        node.next.pre=node.pre</div><div class="line">        <span class="keyword">del</span> self.cache[node.key]</div><div class="line">        <span class="keyword">del</span> node</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertNode</span><span class="params">(self,node)</span>:</span></div><div class="line">        last=self.tail.pre</div><div class="line">        last.next=node</div><div class="line">        node.pre=last</div><div class="line">        node.next=self.tail</div><div class="line">        self.tail.pre=node</div></pre></td></tr></table></figure>

        <a href="/2017/06/25/LRU cache的简单实现/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-哈希表"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2017-06-15 15:54:07" datetime="2017-06-15T07:54:07.000Z"  itemprop="datePublished">2017-06-15</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/算法/">算法</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2017/06/15/哈希表/">哈希表</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    <!-- 
        哈希表与红黑树哈希表使用哈希表可以进行非常快速的查找操作。但是，哈希表究竟是什么玩意儿？很多人避而不谈，虽然知道经常用到，很多语言的内置数据结构像python中的字典，java中的HashMap，都是基于哈希表实现。但哈希表究竟是啥？
哈希是什么？散列（hashing）是电脑科学中一种对资料的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。也译为散列。旧译哈希（误以为是人名而采用了音译）。它也常用作一种资讯安全的实作方法，由一串资料中经过散列算法（Hashing algorithms）计算出来的资料指纹（data fingerprint），经常用来识别档案与资料是否有被窜改，以保证档案与资料确实是由原创者所提供。      —-Wikipedia
哈希函数所有的哈希函数都具有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。
哈希表
若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。

对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。

若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。


建立哈希表这看了一堆概念，老衲甚为头疼。总的来说，哈希表就是一个具备映射关系的表，你可以通过映射关系由键找到值。有没有现成的例子？当然有，不过你直接用就没意思了。
反正就是要实现f(k)，即实现key-value的映射关系。我们试着自己实现以下：
12345678910111213class Map:    def __init__(self):        self.items=[]        def put(self,k,v):        self.items.append((k,v))        def get(self,k):        for key,value in self.items:            if(k==key):                return value
这样实现的Map，查找的时间复杂度为O(n)。“这看上去与key没什么关系啊，这不是顺序查找么，逗我呢？”这只是一个热身，好吧，下面我们根据定义，来搞一个有映射函数的：
12345678910111213class Map:    def __init__(self):        self.items=[None]*100        def hash(self,a):        return a*1+0        def put(self,k,v):        self.items[hash(k)]=v    def get(self,k):        hashcode=hash(k)        return self.items[hashcode]
“这hash函数有点简单啊”是的，它是简单，但简单不代表它不是哈希函数，事实上，它叫直接定址法，是一个线性函数：hash(k)= a*k+b
“为啥初始化就指定了100容量？”必须要指出的是，这个是必须的。你想通过下标存储并访问，对于数组来说，这不可避免。在JDK源码里，你也可以看到，Java的HashMap的初始容量设成了16。你可能说，你这hash函数，我只要key设为100以上，这程序就废了。是啊，它并不完美。这涉及到扩容的事情，稍后再讲。
直接定址法的优点很明显，就是它不会产生重复的hash值。但由于它与键值本身有关系，所以当键值分布很散的时候，会浪费大量的存储空间。所以一般是不会用到直接定址法的。
     -->

    <h1 id="哈希表与红黑树"><a href="#哈希表与红黑树" class="headerlink" title="哈希表与红黑树"></a>哈希表与红黑树</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>使用哈希表可以进行非常快速的查找操作。但是，哈希表究竟是什么玩意儿？很多人避而不谈，虽然知道经常用到，很多语言的内置数据结构像python中的字典，java中的HashMap，都是基于哈希表实现。但哈希表究竟是啥？</p>
<h3 id="哈希是什么？"><a href="#哈希是什么？" class="headerlink" title="哈希是什么？"></a>哈希是什么？</h3><p>散列（hashing）是电脑科学中一种对资料的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。也译为散列。旧译哈希（误以为是人名而采用了音译）。它也常用作一种资讯安全的实作方法，由一串资料中经过散列算法（Hashing algorithms）计算出来的资料指纹（data fingerprint），经常用来识别档案与资料是否有被窜改，以保证档案与资料确实是由原创者所提供。      —-Wikipedia</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>所有的哈希函数都具有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。</p>
<h3 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h3><ul>
<li><p>若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。</p>
</li>
<li><p>对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。</p>
</li>
<li><p>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</p>
</li>
</ul>
<h4 id="建立哈希表"><a href="#建立哈希表" class="headerlink" title="建立哈希表"></a>建立哈希表</h4><p>这看了一堆概念，老衲甚为头疼。总的来说，哈希表就是一个具备映射关系的表，你可以通过映射关系由键找到值。有没有现成的例子？当然有，不过你直接用就没意思了。</p>
<p>反正就是要实现f(k)，即实现key-value的映射关系。我们试着自己实现以下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.items=[]</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,k,v)</span>:</span></div><div class="line">        self.items.append((k,v))</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,k)</span>:</span></div><div class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> self.items:</div><div class="line">            <span class="keyword">if</span>(k==key):</div><div class="line">                <span class="keyword">return</span> value</div></pre></td></tr></table></figure>
<p>这样实现的Map，查找的时间复杂度为O(n)。<br>“这看上去与key没什么关系啊，这不是顺序查找么，逗我呢？”<br>这只是一个热身，好吧，下面我们根据定义，来搞一个有映射函数的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.items=[<span class="keyword">None</span>]*<span class="number">100</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(self,a)</span>:</span></div><div class="line">        <span class="keyword">return</span> a*<span class="number">1</span>+<span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,k,v)</span>:</span></div><div class="line">        self.items[hash(k)]=v</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,k)</span>:</span></div><div class="line">        hashcode=hash(k)</div><div class="line">        <span class="keyword">return</span> self.items[hashcode]</div></pre></td></tr></table></figure>
<p>“这hash函数有点简单啊”<br>是的，它是简单，但简单不代表它不是哈希函数，事实上，它叫直接定址法，是一个线性函数：<br>hash(k)= a*k+b</p>
<p>“为啥初始化就指定了100容量？”<br>必须要指出的是，这个是必须的。你想通过下标存储并访问，对于数组来说，这不可避免。在JDK源码里，你也可以看到，Java的HashMap的初始容量设成了16。你可能说，你这hash函数，我只要key设为100以上，这程序就废了。是啊，它并不完美。这涉及到扩容的事情，稍后再讲。</p>
<p>直接定址法的优点很明显，就是它不会产生重复的hash值。但由于它与键值本身有关系，所以当键值分布很散的时候，会浪费大量的存储空间。所以一般是不会用到直接定址法的。</p>
<a id="more"></a>
<h4 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h4><p>假如某个hash函数产生了一堆哈希值，而这些哈希值产生了冲突怎么办（实际生产环境中经常发生）？在各种哈希表的实现里，处理冲突是必需的一步。<br>比如你定义了一个hash函数：<br><strong>hash(k)=k mod 10</strong><br>假设key序列为：[15,1,24,32,55,64,42,93,82,76]</p>
<table>
<thead>
<tr>
<th style="text-align:left">0</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
<th style="text-align:left">8</th>
<th style="text-align:left">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">93</td>
<td style="text-align:left">24</td>
<td style="text-align:left">15</td>
<td style="text-align:left">76</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">42</td>
<td style="text-align:left"></td>
<td style="text-align:left">64</td>
<td style="text-align:left">55</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">82</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>一趟下来，冲突的元素有四个，下面有几个办法。</p>
<h5 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h5><p>开放定址法就是产生冲突之后去寻找下一个空闲的空间。函数定义为：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/hash_2.png" alt="hash_table" title="">
                </div>
                <div class="image-caption">hash_table</div>
            </figure>
<p>其中，hash(key)是哈希函数，di是增量序列，i为已冲突的次数。</p>
<ul>
<li>线性探测法<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/linear_probing.png" alt="hash_table" title="">
                </div>
                <div class="image-caption">hash_table</div>
            </figure>
</li>
</ul>
<p>即di=i，或者其它线性函数。相当于逐个探测存放地址的表，直到查找到一个空单元，然后放置在该单元。</p>
<p><strong>[15,1,24,32,55,64,42,93,82,76]</strong></p>
<p>可以看到，在55之前都还没冲突：</p>
<table>
<thead>
<tr>
<th style="text-align:left">0</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
<th style="text-align:left">8</th>
<th style="text-align:left">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">1</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left">24</td>
<td style="text-align:left">15</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>此时插入55，与15冲突，应用线性探测，此时i=1，可以得到：</p>
<table>
<thead>
<tr>
<th style="text-align:left">0</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
<th style="text-align:left">8</th>
<th style="text-align:left">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">1</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left">24</td>
<td style="text-align:left">15</td>
<td style="text-align:left">55</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>再插入64，冲突不少，要取到i=3：</p>
<table>
<thead>
<tr>
<th style="text-align:left">0</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
<th style="text-align:left">8</th>
<th style="text-align:left">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">1</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left">24</td>
<td style="text-align:left">15</td>
<td style="text-align:left">55</td>
<td style="text-align:left">64</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>插入42，i=1：</p>
<table>
<thead>
<tr>
<th style="text-align:left">0</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
<th style="text-align:left">8</th>
<th style="text-align:left">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">42</td>
<td style="text-align:left">24</td>
<td style="text-align:left">15</td>
<td style="text-align:left">55</td>
<td style="text-align:left">64</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>插入93，i=5：</p>
<table>
<thead>
<tr>
<th style="text-align:left">0</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
<th style="text-align:left">8</th>
<th style="text-align:left">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">42</td>
<td style="text-align:left">24</td>
<td style="text-align:left">15</td>
<td style="text-align:left">55</td>
<td style="text-align:left">64</td>
<td style="text-align:left">93</td>
</tr>
</tbody>
</table>
<p>插入82，i=7：</p>
<table>
<thead>
<tr>
<th style="text-align:left">0</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
<th style="text-align:left">8</th>
<th style="text-align:left">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">42</td>
<td style="text-align:left">24</td>
<td style="text-align:left">15</td>
<td style="text-align:left">55</td>
<td style="text-align:left">64</td>
<td style="text-align:left">93</td>
<td style="text-align:left">82</td>
</tr>
</tbody>
</table>
<p>插入76，i=4：</p>
<table>
<thead>
<tr>
<th style="text-align:left">0</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
<th style="text-align:left">8</th>
<th style="text-align:left">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">76</td>
<td style="text-align:left">1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">42</td>
<td style="text-align:left">24</td>
<td style="text-align:left">15</td>
<td style="text-align:left">55</td>
<td style="text-align:left">64</td>
<td style="text-align:left">93</td>
<td style="text-align:left">82</td>
</tr>
</tbody>
</table>
<p>发现越到后面，冲突的越来越离谱，因为表的大小选择也很重要，此例中选择了10作为表的大小，所以容易产生冲突。<strong>一般来讲，越是质数，mod取余就越可能分布的均匀</strong>。</p>
<ul>
<li><p>平方探测</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/quadratic_probing.png" alt="hash_table" title="">
                </div>
                <div class="image-caption">hash_table</div>
            </figure>
<p>这称作平方探测法，一个道理，也是查找到一个空单元然后放进去。这里就不一步一步说明了=。=</p>
</li>
<li><p>伪随机探测<br>di是一个随机数序列。<br>“随机数？那get的时候咋办？也是随机数啊，怎么确保一致？”<br>所以说了，是伪随机数。其实我们在计算机里接触的几乎都是伪随机数，只要是由确定算法生成的，都是伪随机。只要种子确定，生成的序列都是一样的。序列都一样，那不就可以了么=。=</p>
</li>
</ul>
<h5 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h5><p>这是另外一种类型解决冲突的办法，散列到同一位置的元素，不是继续往下探测，而是在这个位置是一个链表，这些元素则都放到这一个链表上。java的HashMap就采用的是这个。</p>
<h5 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h5><p>如果一次不够，就再来一次，直到冲突不再发生。</p>
<h5 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h5><p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表(注意：在这个方法里面是把元素分开两个表来存储)。</p>
<p>说了这么一堆，举个例子，用开放地址法（线性探测）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.hash_table=[[<span class="keyword">None</span>,<span class="keyword">None</span>]<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>)]</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(self,k,i)</span>:</span></div><div class="line">        h_value=(k+i)%<span class="number">11</span></div><div class="line">        <span class="keyword">if</span> self.hash_table[h_value][<span class="number">0</span>]==k:</div><div class="line">            <span class="keyword">return</span> h_value</div><div class="line">        <span class="keyword">if</span> self.hash_table[h_value][<span class="number">0</span>]!=<span class="keyword">None</span>:</div><div class="line">            i+=<span class="number">1</span></div><div class="line">            h_value=self.hash(k,i)</div><div class="line">        <span class="keyword">return</span> h_value</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,k,v)</span>:</span></div><div class="line">        hash_v=self.hash(k,<span class="number">0</span>)</div><div class="line">        self.hash_table[hash_v][<span class="number">0</span>]=k</div><div class="line">        self.hash_table[hash_v][<span class="number">1</span>]=v</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,k)</span>:</span></div><div class="line">        hash_v=self.hash(k,<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> self.hash_table[hash_v][<span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>“能不能不要定死长度？11个完全不够用啊”</p>
<p>这是刚才的问题，所以有了另外一个概念，叫做载荷因子（load factor）。载荷因子的定义为：<br><strong>α= 已有的元素个数/表的长度</strong></p>
<p><strong>由于表长是定值， α与“填入表中的元素个数”成正比，所以， α越大，表明填入表中的元素越多，产生冲突的可能性就越大</strong>；反之，α越小，标明填入表中的元素越少，产生冲突的可能性就越小。实际上，散列表的平均查找长度是载荷因子 α的函数，只是不同处理冲突的方法有不同的函数。</p>
<p>所以当到达一定程度，表的长度是要变的，即resize=。=像java的HashMap，载荷因子被设计为0.75；超过0.8，cpu的cache missing会急剧上升。可以看下这篇讨论：<br><a href="https://www.zhihu.com/question/22911718" target="_blank" rel="external">https://www.zhihu.com/question/22911718</a></p>
<p>具体扩容多少，一般选择扩到已插入元素数量的两倍，java也是这么做的。</p>
<p>接着上面，再升级一下我们的map：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.capacity=<span class="number">11</span></div><div class="line">        self.hash_table=[[<span class="keyword">None</span>,<span class="keyword">None</span>]<span class="keyword">for</span> i <span class="keyword">in</span> range(self.capacity)]</div><div class="line">        self.num=<span class="number">0</span></div><div class="line">        self.load_factor=<span class="number">0.75</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(self,k,i)</span>:</span></div><div class="line">        h_value=(k+i)%self.capacity</div><div class="line">        <span class="keyword">if</span> self.hash_table[h_value][<span class="number">0</span>]==k:</div><div class="line">            <span class="keyword">return</span> h_value</div><div class="line">        <span class="keyword">if</span> self.hash_table[h_value][<span class="number">0</span>]!=<span class="keyword">None</span>:</div><div class="line">            i+=<span class="number">1</span></div><div class="line">            h_value=self.hash(k,i)</div><div class="line">        <span class="keyword">return</span> h_value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(self)</span>:</span></div><div class="line">        self.capacity=self.num*<span class="number">2</span> <span class="comment">#扩容到原有元素数量的两倍</span></div><div class="line">        temp=self.hash_table[:]</div><div class="line">        self.hash_table=[[<span class="keyword">None</span>,<span class="keyword">None</span>]<span class="keyword">for</span> i <span class="keyword">in</span> range(self.capacity)] </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> temp:</div><div class="line">            <span class="keyword">if</span>(i[<span class="number">0</span>]!=<span class="keyword">None</span>):  <span class="comment">#把原来已有的元素存入</span></div><div class="line">                hash_v=self.hash(i[<span class="number">0</span>],<span class="number">0</span>)</div><div class="line">                self.hash_table[hash_v][<span class="number">0</span>]=i[<span class="number">0</span>]</div><div class="line">                self.hash_table[hash_v][<span class="number">1</span>]=i[<span class="number">1</span>]</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,k,v)</span>:</span></div><div class="line">        hash_v=self.hash(k,<span class="number">0</span>)</div><div class="line">        self.hash_table[hash_v][<span class="number">0</span>]=k</div><div class="line">        self.hash_table[hash_v][<span class="number">1</span>]=v</div><div class="line">        self.num+=<span class="number">1</span>                 <span class="comment">#暂不考虑key重复的情况，具体自己可以优化</span></div><div class="line">        <span class="keyword">if</span>(self.num/len(self.hash_table)&gt;self.load_factor):<span class="comment"># 如果比例大于载荷因子</span></div><div class="line">            self.resize()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,k)</span>:</span></div><div class="line">        hash_v=self.hash(k,<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> self.hash_table[hash_v][<span class="number">1</span>]</div></pre></td></tr></table></figure></p>
<p>看上面的函数，可以看到resize是一个比较耗时的操作，更何况我写的不是很好。可以去看一下Java的HashMap的hash方法和resize方法，其中的思路要精妙的多。</p>
<p>关于哈希表，原理的东西都基本差不多了。可以看到，它本质要解决的是查找时间的问题。如果顺序查找的话，时间复杂度为O(n)；而哈希表，时间复杂度则为O(1)！直接甩了一个次元有木有，这也就是为什么在大量数据存储查找的时候，哈希表得到大量应用的原因。</p>

        <a href="/2017/06/15/哈希表/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-八大排序算法（python实现）"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2017-06-13 15:54:07" datetime="2017-06-13T07:54:07.000Z"  itemprop="datePublished">2017-06-13</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/算法/">算法</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2017/06/13/八大排序算法（python实现）/">八大排序算法（python描述）</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    <!-- 
        八大排序算法（python描述）冒泡排序冒泡排序是最简单的排序？其实我并不觉得，只是在学算法的时候第一个接触的恰恰是冒泡排序。什么，你说哪个是最简单的？这个仁者见仁吧。。。

基本思想： 两两比较，然后决定是否交换

代码如下：123456789def bubble_sort(lists):    length=len(lists)    for i in range(0,length):        for j in range(i+1,length):            if(lists[i]&gt;lists[j]):                temp=lists[i]                lists[i]=lists[j]                lists[j]=temp    return lists
再来分析一波时间复杂度，嗯，这个时间复杂度应该为：0+1+2+3+······+n-1即n的累加，等于n*(n-1)/2。时间复杂度为O(n²)
直接选择排序好吧，我只是单纯认为这个是最简单的排序。设想一下吧，假如给你一套扑克牌，从A到K一共13张乱序的牌，你会怎么把它排好序？我想你应该是这样，先把A选出来，再把2选出来，以此类推，最后把K选出来。你难道不是这样？别告诉我你是按照冒泡那样排的，如果你真那样做的，我服你=。=

基本思想： 第1趟，在待排序记录r[1] ~ r[n]中选出最小的记录，将它与r[1]交换；第2趟，在待排序记录r[2] ~ r[n]中选出最小的记录，将它与r[2]交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。

代码如下：12345678910111213def select_sort(lists):    length=len(lists)    index =0     while(index&lt;length):        min=index        for i in range(index,length):            if(lists[i]&lt;lists[min]):                min=i        temp=lists[index]        lists[index]=lists[min]        lists[min]=temp        index+=1    return lists
时间复杂度：这看上去和冒泡排序是一样的，所以复杂度也是O(n²)
插入排序现在要看得是插入排序，怎么个插入法？

基本思想： 通俗点讲，就是在已经排好序的数组中，插入将要插入的数，使得这个数组依然有序。

Wtf？我为什么要插入？数组就在那而已嘛。。。百科上有张图可以让你理解一下:

                
                    
                    
                
                insert_sort
            
代码如下：12345678910111213def insert_sort(lists):    length=len(lists)    for i in range(1,length):        j=i-1        key=lists[i]        while j&gt;=0 and lists[j]&gt;key:            # while j&gt;=0:                # if(lists[j]&gt;key): 注意了，有些哥们儿是这样写的，但其实这样浪费了比较操作，显得比冒泡还慢                # 其实终止条件是遇上前面第一个小的就停止循环，因为之前的都是排好序的            lists[j+1]=lists[j]            lists[j]=key            j-=1    return lists
时间复杂度：这东西一看，时间复杂度也是O(n²),在最坏的情况下，和冒泡是一样的，但是万一没那么坑爹(不需要每趟都要和之前的所有元素都比较)，它就比冒泡要快一点。
     -->

    <h1 id="八大排序算法（python描述）"><a href="#八大排序算法（python描述）" class="headerlink" title="八大排序算法（python描述）"></a>八大排序算法（python描述）</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是最简单的排序？其实我并不觉得，只是在学算法的时候第一个接触的恰恰是冒泡排序。<br>什么，你说哪个是最简单的？这个仁者见仁吧。。。</p>
<ul>
<li>基本思想： 两两比较，然后决定是否交换</li>
</ul>
<p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(lists)</span>:</span></div><div class="line">    length=len(lists)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,length):</div><div class="line">            <span class="keyword">if</span>(lists[i]&gt;lists[j]):</div><div class="line">                temp=lists[i]</div><div class="line">                lists[i]=lists[j]</div><div class="line">                lists[j]=temp</div><div class="line">    <span class="keyword">return</span> lists</div></pre></td></tr></table></figure></p>
<p>再来分析一波时间复杂度，嗯，这个时间复杂度应该为：<br>0+1+2+3+······+n-1<br>即n的累加，等于n*(n-1)/2。时间复杂度为O(n²)</p>
<h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><p>好吧，我只是单纯认为这个是最简单的排序。<br>设想一下吧，假如给你一套扑克牌，从A到K一共13张乱序的牌，你会怎么把它排好序？<br>我想你应该是这样，先把A选出来，再把2选出来，以此类推，最后把K选出来。<br>你难道不是这样？别告诉我你是按照冒泡那样排的，如果你真那样做的，我服你=。=</p>
<ul>
<li>基本思想： 第1趟，在待排序记录r[1] ~ r[n]中选出最小的记录，将它与r[1]交换；<br>第2趟，在待排序记录r[2] ~ r[n]中选出最小的记录，将它与r[2]交换；<br>以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。</li>
</ul>
<p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(lists)</span>:</span></div><div class="line">    length=len(lists)</div><div class="line">    index =<span class="number">0</span> </div><div class="line">    <span class="keyword">while</span>(index&lt;length):</div><div class="line">        min=index</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index,length):</div><div class="line">            <span class="keyword">if</span>(lists[i]&lt;lists[min]):</div><div class="line">                min=i</div><div class="line">        temp=lists[index]</div><div class="line">        lists[index]=lists[min]</div><div class="line">        lists[min]=temp</div><div class="line">        index+=<span class="number">1</span></div><div class="line">    <span class="keyword">return</span> lists</div></pre></td></tr></table></figure></p>
<p>时间复杂度：<br>这看上去和冒泡排序是一样的，所以复杂度也是O(n²)</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>现在要看得是插入排序，怎么个插入法？</p>
<ul>
<li>基本思想： 通俗点讲，就是在已经排好序的数组中，插入将要插入的数，使得这个数组依然有序。</li>
</ul>
<p>Wtf？我为什么要插入？数组就在那而已嘛。。。百科上有张图可以让你理解一下:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/insert_sort.png" alt="insert_sort" title="">
                </div>
                <div class="image-caption">insert_sort</div>
            </figure>
<p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(lists)</span>:</span></div><div class="line">    length=len(lists)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,length):</div><div class="line">        j=i<span class="number">-1</span></div><div class="line">        key=lists[i]</div><div class="line">        <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> lists[j]&gt;key:</div><div class="line">            <span class="comment"># while j&gt;=0:</span></div><div class="line">                <span class="comment"># if(lists[j]&gt;key): 注意了，有些哥们儿是这样写的，但其实这样浪费了比较操作，显得比冒泡还慢</span></div><div class="line">                <span class="comment"># 其实终止条件是遇上前面第一个小的就停止循环，因为之前的都是排好序的</span></div><div class="line">            lists[j+<span class="number">1</span>]=lists[j]</div><div class="line">            lists[j]=key</div><div class="line">            j-=<span class="number">1</span></div><div class="line">    <span class="keyword">return</span> lists</div></pre></td></tr></table></figure></p>
<p>时间复杂度：<br>这东西一看，时间复杂度也是O(n²),在最坏的情况下，和冒泡是一样的，但是万一没那么坑爹(不需要每趟都要和之前的所有元素都比较)，<br>它就比冒泡要快一点。</p>
<a id="more"></a>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是一个叫希尔的人发明的，它是直接插入排序的进化版本。</p>
<ul>
<li>基本思想：对数组按增量分组，组内再进行直接插入排序</li>
</ul>
<p>什么增量分组？还是直接从百科上借张图来可能好理解一点：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/shell_sort.jpg" alt="insert_sort" title="">
                </div>
                <div class="image-caption">insert_sort</div>
            </figure>
<p>所以，这个增量怎么确定？其实关于这个增量，都够人研究的了，有专门的论文讨论哪个增量序列好。<br>我们在这里假设起始增量为数组长度的一半，后面则除以2取整，直到1结束。</p>
<p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(lists)</span>:</span></div><div class="line">    length=len(lists)</div><div class="line">    step=length/<span class="number">2</span></div><div class="line">    <span class="keyword">while</span> step&gt;=<span class="number">1</span>:                      <span class="comment"># 比起直接选择排序，就多了这一层</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(step,length):</div><div class="line">            j=i-step</div><div class="line">            key=lists[i]</div><div class="line">            <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> lists[j]&gt;key:</div><div class="line">                lists[j+step]=lists[j]</div><div class="line">                lists[j]=key</div><div class="line">                j-=step</div><div class="line">        step/=<span class="number">2</span></div><div class="line">    <span class="keyword">return</span> lists</div></pre></td></tr></table></figure></p>
<p>时间复杂度:<br>“喂，这看上去多了一层while循环了，还搞个毛啊。。。”<br>没错，这确实是多了一层while循环，但是你想，你不用每趟都像增量为1的直接插入排序那样交换那么多次啊。。。<br>本质上讲，希尔排序算法是直接插入排序算法的一种改进，减少了其复制的次数，速度要快很多。 原因是，当n值很大时数据项每一趟排序需要移动的个数很少，但数据项的距离很长。当n值减小时每一趟需要移动的数据增多，此时已经接近于它们排序后的最终位置。 正是这两种情况的结合才使希尔排序效率比插入排序高很多。</p>
<p>你把代码复制过去，自己跑一跑，会发现到后面，最里层的while循环会很快跳出，甚至都进不去，实际的数据交换操作是比普通的直接插入排序要少很多的。希尔排序的时间复杂度取决于增量序列的选取，在本例中这个增量序列条件下（此增量序列叫希尔增量），希尔排序的时间复杂度为O(n²)。当然还有更好的增量序列，不过，希尔排序时间复杂度的下界是nlog2n。<br>“什么，不都三层循环了么，你逗我呢？”<br>“。。。”<br>呃，你可以看下代码里的增量序列，每次都除以2。。。不知道你们之前学数学有没有接触过1+2+4+8+······+m    =。=<br>而这个m就是你设置的起始增量。你看，其实最外层while的次数就是m以2为底的对数log2(m)。<br>“那岂不是O(n²logn)?”<br>“好吧，我承认这比较难。”<br>这个确实困扰到我了，上面说了，希尔排序算法的性能与所选取的增量序列有很大关系。只对特定的待排序记录序列，可以准确地估算关键词的比较次数和对象移动次数。不知道有谁可以分析出在有增量序列的情况下，while循环内的操作时间复杂度如何计算？内层的while的break触发是否与增量有关系？</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>好了，终于到了大名鼎鼎的快排了。顾名思义，它就是快。</p>
<ul>
<li>基本思想：  通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，<br>然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</li>
</ul>
<p>举例说明一下吧，这个可能不是太好理解。假设要排序的序列为</p>
<p>16,7,3,20,17,8,19,54,12</p>
<p>游戏规则：</p>
<ul>
<li>首先，取第一个数作为key，同时你有两个指针，一个左指针，一个右指针，右指针从最右边往左扫描，左指针则从最左往右扫描，从右指针开始；</li>
<li>右指针往左扫描过程中，遇上比key大的，则跳过，右指针左移。遇上比key小的，则把右指针的数换到左指针所在的位置，然后，比较操作切换成左指针；</li>
<li>左指针往右扫描过程中，遇上比key小的，则跳过，左指针右移。遇上比key大的，则把左指针的数换到右指针所在的位置，然后，比较操作切换成右指针；</li>
<li>左指针和右指针下标相遇，停止，将key放到该位置；<br>估计还是不明白，好吧，开始跑:</li>
</ul>
<p><strong>key: 16</strong>     16,7,3,20,17,8,19,54,<strong>12</strong> 第一个数是16吧？右指针开始了，遇到12，根据规则，12比16小，直接换到左边，切换操作到左指针；</p>
<p><strong>key: 16</strong>     12,<strong>7</strong>,3,20,17,8,19,54,<strong>12</strong> 好，这下从左边看7，7比16小，根据规则，不用换，但左指针右移；</p>
<p><strong>key: 16</strong>     12,7,<strong>3</strong>,20,17,8,19,54,<strong>12</strong> 继续看3，3还是比16小，根据规则，不用换，左指针左移；</p>
<p><strong>key: 16</strong>     12,7,3,<strong>20</strong>,17,8,19,54,<strong>12</strong> 继续看20，20比16大，直接换到右边，切换操作到右指针；</p>
<p><strong>key: 16</strong>     12,7,3,<strong>20</strong>,17,8,19,54,<strong>20</strong> 看20，20比16大，根据规则，不用换，右指针左移；</p>
<p><strong>key: 16</strong>     12,7,3,<strong>20</strong>,17,8,19,<strong>54</strong>,20 看54，54比16大，不用换，右指针左移；</p>
<p><strong>key: 16</strong>     12,7,3,<strong>20</strong>,17,8,<strong>19</strong>,54,20 19也比16大，继续左移；</p>
<p><strong>key: 16</strong>     12,7,3,<strong>20</strong>,17,<strong>8</strong>,19,54,20 8比16小，根据规则，直接换到左边，切换操作到左指针；</p>
<p><strong>key: 16</strong>     12,7,3,<strong>8</strong>,17,<strong>8</strong>,19,54,20  再来看左边，8比16小，根据规则，不用换，左指针右移；</p>
<p><strong>key: 16</strong>     12,7,3,8,<strong>17</strong>,<strong>8</strong>,19,54,20  17比16大，直接换，切换操作到右指针；</p>
<p><strong>key: 16</strong>     12,7,3,8,<strong>17</strong>,<strong>17</strong>,19,54,20 再来看右边，17比16大，不用换，右指针左移，额(⊙o⊙)…这么一换，和左指针相遇了哦</p>
<p><strong>key: 16</strong>     12,7,3,8,<strong>17</strong>,17,19,54,20     终于相遇了，那就根据规则把key：16 放到这吧。</p>
<p>一趟之后的最终结果：<br><strong>key: 16</strong>     12,7,3,8,<strong>16</strong>,17,19,54,20 </p>
<p>这样子走了一趟后，你可以看到key：16把整个数组分成了两部分。知道接下来干嘛了吧？没错，就是递归，对这两个子区间分别都这样再跑，直到分解的部分长度为1。</p>
<p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(lists)</span>:</span></div><div class="line">    low= <span class="number">0</span></div><div class="line">    high=len(lists)<span class="number">-1</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort_helper</span><span class="params">(lists,low,high)</span>:</span></div><div class="line">        left=low</div><div class="line">        right=high</div><div class="line">        key=lists[low]    <span class="comment"># 选择第一个元素作为key</span></div><div class="line">        <span class="keyword">while</span>(left&lt;right):</div><div class="line">            <span class="keyword">while</span>(list[right]&gt;=key <span class="keyword">and</span> left&lt;right):</div><div class="line">                right-=<span class="number">1</span></div><div class="line">            lists[left]=lists[right]</div><div class="line">            <span class="keyword">while</span>(list[left]&lt;=key <span class="keyword">and</span> left&lt;right):</div><div class="line">                left+=<span class="number">1</span></div><div class="line">            lists[right]=lists[left]</div><div class="line">        lists[left]=key</div><div class="line">        <span class="keyword">if</span>(low&lt;left):</div><div class="line">            quick_sort_helper(lists,low,left<span class="number">-1</span>)</div><div class="line">        <span class="keyword">if</span>(high&gt;left):</div><div class="line">            quick_sort_helper(lists,left+<span class="number">1</span>,high)</div><div class="line">    quick_sort_helper(lists,low,high)</div><div class="line">    <span class="keyword">return</span> lists</div></pre></td></tr></table></figure></p>
<p>分析一波时间复杂度，假设每次划分子区间都平均，为n/2，那意味着快排结束的越早，时间复杂度为O(nlogn)。当然最坏情况自然是O(n²)了（数据恰好是倒序就是这种情况，你可以试试）。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是啥？堆排序是针对具有堆结构的数据进行的排序。</p>
<h3 id="二叉堆的定义"><a href="#二叉堆的定义" class="headerlink" title="二叉堆的定义"></a>二叉堆的定义</h3><p>二叉堆是完全二叉树或者是近似完全二叉树。</p>
<p>二叉堆满足二个特性：</p>
<p>1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</p>
<p>2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。</p>
<p>当父结点的键值总是大于或等于任何一个子节点的键值时为<strong>最大堆</strong>。当父结点的键值总是小于或等于任何一个子节点的键值时为<strong>最小堆</strong>。</p>
<p>最大堆示例图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_6.png" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure>
<ul>
<li><p>基本思想：堆排序其实也是一种选择排序，是一种树形选择排序。只不过直接选择排序中，为了从R[1…n]中选择最大记录，需比较n-1次，然后从R[1…n-2]中选择最大记录需比较n-2次。事实上这n-2次比较中有很多已经在前面的n-1次比较中已经做过，而树形选择排序恰好利用树形的特点保存了部分前面的比较结果，因此可以减少比较次数。</p>
</li>
<li><p>步骤：</p>
</li>
</ul>
<ol>
<li>建堆</li>
<li>调整堆</li>
<li>排序<br>排序的时候，根据最大堆或最小堆的定义，堆顶元素永远最大或最小，与堆顶元素交换，并实时调整堆，最后可使整个数组有序。事实上，排序的过程也是一个不断在调整堆的过程。</li>
</ol>
<p>可能有点晦涩难懂，还是上图吧，假设需要排序的数组为：[12,56,32,17,6,39,25]，要构造的堆是最大堆。</p>
<ol>
<li><p>建堆：<br>原始是这样的：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_1.png" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure>
</li>
<li><p>调整堆：<br>从倒数第一个非叶节点开始，</p>
</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_2.jpg" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure>
<p>倒数第二个，56比10和6都大，此左子树符合最大堆定义，不用动：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_3.jpg" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure></p>
<p>12比56和39小，选较大的，调整节点：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_4.jpg" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure></p>
<p>你该不会以为这样就完了吧？可以看到把56换到根节点后，12这个节点又在搞事，还需调整：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_5.jpg" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure></p>
<p>调整完毕，构造了一个最大堆：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_6.png" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure></p>
<ol>
<li>排序：<br>记住，堆排序的过程，不仅仅是单纯地和堆顶元素进行交换，每交换之后都要检查一遍，对整个堆进行调整。</li>
</ol>
<p>那么继续，25比56小，直接换，请注意，你已经把最大的元素拿下来了，所以，56就被此最大堆“开除”了。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_7.jpg" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure></p>
<p>然后你发现，这一换不得了，堆顶不符合最大堆定义了，需要调整堆:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_8.jpg" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure></p>
<p>这么一调，除了56外，重新符合了最大堆的定义，那么再从25开始，继续替换堆顶元素：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_9.jpg" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure></p>
<p>这样，39被“开除”，但此时又不符合最大堆定义，又得调整：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_10.jpg" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure></p>
<p>之后的操作，我用图来演示，估计你也能看得懂了：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_11.jpg" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_12.jpg" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_13.jpg" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_14.jpg" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure></p>
<p>所以，最终结果就是：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/heap_15.png" alt="heap_sort" title="">
                </div>
                <div class="image-caption">heap_sort</div>
            </figure></p>
<p>其实不是“开除”，而是把元素一个一个选出来，有些人直接看定义看不明白，看图总知道怎么选的了吧？我知道有疑问，估计是，为什么在创建堆的时候，调整堆的策略跟后面堆排序时调整堆的策略看上去有点不一样？</p>
<p>有一点，要搞明白，在创建堆之后，我的目的是要这整个堆调整成一个最大堆；而后面堆排序，我是要利用最大堆的性质，不断地把堆顶元素选出来，同时把未选的剩下元素调整成最大堆。</p>
<p>什么？这两步调整堆的策略不一样？其实是一样的，调整堆，其实就在递归纠正整个树的过程，你只需要关心以某个节点为根节点的树及其子树是否满足最大堆而已，是就不调整，不是就调整。</p>
<ul>
<li>创建堆的时候，是从第一个非叶节点开始，倒序一直调整到根节点，当然每一步调整都用到递归；</li>
<li>堆排序的时候，调整的对象一直是根节点，当然每一步调整也都用到递归；</li>
</ul>
<p>具体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(lists)</span>:</span></div><div class="line">    length=len(lists)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_heap</span><span class="params">(lists,length)</span>:</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length/<span class="number">2</span>)[::<span class="number">-1</span>]: <span class="comment">#创建堆调整的时候，是从非叶节点开始的哦！！！</span></div><div class="line">            adjust_heap(lists,i,length)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span><span class="params">(lists,i,length)</span>:</span></div><div class="line">        lchild = i*<span class="number">2</span>+<span class="number">1</span></div><div class="line">        rchild=i*<span class="number">2</span>+<span class="number">2</span></div><div class="line">        max=i</div><div class="line">        <span class="keyword">if</span>(lchild&lt;length <span class="keyword">and</span> lists[max]&lt;lists[lchild]):</div><div class="line">            max = lchild</div><div class="line">        <span class="keyword">if</span>(rchild&lt;length <span class="keyword">and</span> lists[max]&lt;lists[rchild]):</div><div class="line">            max = rchild</div><div class="line">        <span class="keyword">if</span> max!=i:</div><div class="line">            lists[i],lists[max]=lists[max],lists[i]</div><div class="line">            adjust_heap(lists,max,length)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_sort_helper</span><span class="params">(lists)</span>:</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length)[::<span class="number">-1</span>]:</div><div class="line">            lists[<span class="number">0</span>],lists[i]=lists[i],lists[<span class="number">0</span>]</div><div class="line">            adjust_heap(lists,<span class="number">0</span>,i)          <span class="comment"># 这一步，就是不断开除，不断调整节点的意思</span></div><div class="line">    create_heap(lists,length</div><div class="line">    heap_sort_helper(lists)</div><div class="line">    <span class="keyword">return</span> lists</div></pre></td></tr></table></figure></p>
<p>最后，还是要分析一波时间复杂度，<br>先是建堆，这是一个从非叶节点开始调整的过程，假设树的高度为K（编号1到k层），那总共的元素，至多为2^k-1。从k-1层开始调整，第k-1层的元素数量是2^(k-2)，这个应该没有疑问，在这一层上的元素，所需调整的次数为1；而每往上一层，次数就要加1。所以，总共时间可以归结为：<br>S= 2^(k-2)<em>1+ 2^(k-3)</em>2+ 2^(k-4)<em>3+……+1</em>(k-1)</p>
<p>这种数列求和，就用错位相减法，先两边都乘以2：</p>
<p>2S= 2^(k-1)+2^(k-2)<em>2+ 2^(k-3)</em>3+……+2*(k-1)</p>
<p>再减去原来的式子，刚好得到：<br>S= 2^(k-1)+2^(k-2)+……+1-k</p>
<p>除去最后一项，是一个等比数列求和，根据求和公式，可以得到：S= 2^k-1-k<br>如果节点数量为n，那么n与k的关系就是n=2^k-1,k=log(n+1),所以，S=n-log(n+1),<br>∴建立最大堆的时间复杂度为O(n)。</p>
<p>明白了这个，那么排序的时间复杂度，应该也好计算。因为交换之后始终调整的是根节点，由上可知，根节点需要调整的次数是k-1，而且你要知道，每一步交换还“开除”了一个元素，当然，我们也不用算那么精准了，直接<br>S= n<em>(k-1)=n</em>(log(n+1)-1)<br>∴排序的时间复杂度为O(nlogn)。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li><p>思想：建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
</li>
<li><p>过程： 比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p>
</li>
</ul>
<p>看这些定义，总是没那么形象，所以还是按照快排那样子，一步一步演示一下吧，继续拿上边的数组,<br>[12,56,32,17,6,39,25]</p>
<p><strong>[12 56 32 17 6 39 25]</strong>               初始数组</p>
<p><strong>[[12 56 32][17 6 39 25]]</strong>            分而治之，分成两部分，一部分[12 56 32]，一部分[17 6 39 25]</p>
<p><strong>[[[12][56 32]][17 6 39 25]]</strong>         先只关心左边（强调一下，你当然可以同时操作右边，我只想说在串行操作下，算法是怎么跑的），对[12 56 32]继续划分，12被划分出来了，在只有一个元素的子部分，当然也就排好序了</p>
<p><strong>[[[12][[56][32]]][17 6 39 25]]</strong>      只要还没有划分到只有一个元素，就继续划分</p>
<p><strong>[[[12][32 56]][17 6 39 25]]</strong>        合并56和32，并排好序</p>
<p><strong>[[12 32 56][17 6 39 25]]</strong>            合并[12]跟[32 56]，并排好序</p>
<p><strong>[[12 32 56][[17 6] [39 25]]]</strong>        再来看刚才右边的部分，和左边一样，划分</p>
<p><strong>[[12 32 56][[[17] [6]] [39 25]]</strong>     划分</p>
<p><strong>[[12 32 56][[6 17] [39 25]]]</strong>       合并17和6，并排好序</p>
<p><strong>[[12 32 56][[6 17] [[39] [25]]]]</strong>    划分</p>
<p><strong>[[12 32 56][[6 17] [25 39]]]</strong>        合并39合25，并排好序</p>
<p><strong>[[12 32 56][6 17 25 39]]</strong>            合并[6 17]和[25 39]，并排好序</p>
<p><strong>[6 12 17 25 32 39 56]</strong>              合并[12 32 56]和[6 17 25 39]，并排好序</p>
<p>这样走下来，整个数组就排完序了。</p>
<p>乍一看，貌似还挺费劲的，划分然后又合并，折不折腾。。。<br>好吧，我先不上代码，来分析一下它的时间复杂度。可以看出，只要是划分了多少次，就要合并多少次。划分的次数不用看，当然是n了，有多少个就要分到底嘛=。=但是你这样二分法下来，二分了多少次，才确保全部子区间都划分成了只包含一个元素？logn。很显然啊，如果你看了前面几种排序，这应该是很简单的，2^k=n,k=logn。</p>
<p>时间复杂度为O(nlogn)。嗯，毫无疑问。可能有些疑问说你咋知道{12 32 56}和{6 17 25 39}合并排序的时候，比较次数就是7，而不是3*4=12？拜托，这俩子区间本身已经排好序了好不好？根据上面的过程描述，一路向右比较有疑问？那我直接上代码，自己跑跑便知：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(lists)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></div><div class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></div><div class="line">        result = []</div><div class="line">        <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</div><div class="line">            <span class="keyword">if</span> left[i] &lt;= right[j]:</div><div class="line">                result.append(left[i])</div><div class="line">                i += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                result.append(right[j])</div><div class="line">                j += <span class="number">1</span></div><div class="line">        result += left[i:]</div><div class="line">        result += right[j:]</div><div class="line">        <span class="keyword">return</span> result</div><div class="line">    <span class="keyword">if</span> len(lists) &lt;= <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> lists</div><div class="line">    num = len(lists) / <span class="number">2</span></div><div class="line">    left = merge_sort(lists[:num])</div><div class="line">    right = merge_sort(lists[num:])</div><div class="line">    <span class="keyword">return</span> merge(left, right)</div></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>其实，八大排序（传统版本，不包含优化）里速度能够跟快排相比（其实归并就跟快排不多快了）甚至超过快排的就是基排了。它相当的快，在我写的这些python排序程序里，它几乎每次都比快排要快，在数据量大的情况下，甚至比快排快一倍，后面我会贴图看看这些排序算法的运行时间。</p>
<ul>
<li>思想：基排的思想非常简单，它不像其他算法那样，都是基于直接的数值比较，它是基于数字在不同位数上的排序。<br>思想是分配k个桶，编号0到k-1,从数值第0位开始按照桶编号对号入座（相当于在排序），以此类推直到最高位排序完毕。</li>
</ul>
<p>举个例子吧，这次来个稍长一点的，[4,2,5,54,23,24,11,3234,3432,56,21,33,663,22,341,52]。</p>
<p>一般我们表示的是10进制数，假设我们给十进制数分配10个桶，编号0~9。</p>
<p>先来排个位数的，对号入座：</p>
<p><strong>0</strong>    </p>
<p><strong>1</strong>           11,21,341,</p>
<p><strong>2</strong>           2,3432,22,52,</p>
<p><strong>3</strong>           23,33,663,</p>
<p><strong>4</strong>           4,54,24,3234,</p>
<p><strong>5</strong>           5,</p>
<p><strong>6</strong>           56,</p>
<p><strong>7</strong></p>
<p><strong>8</strong></p>
<p><strong>9</strong></p>
<p>排完个位数之后，数组变为：[11,21,341,2,3432,22,52,23,33,663,4,54,24,3234,5,56]</p>
<p>接着是十位数上的排序，继续对号入座：</p>
<p><strong>0</strong>           2,4,5,  </p>
<p><strong>1</strong>           11,</p>
<p><strong>2</strong>           21,22,23,24,</p>
<p><strong>3</strong>           3432,33,3234,</p>
<p><strong>4</strong>           341,</p>
<p><strong>5</strong>           52,54,56,</p>
<p><strong>6</strong>           663</p>
<p><strong>7</strong></p>
<p><strong>8</strong></p>
<p><strong>9</strong></p>
<p>排完十位数之后，数组变为：[2,4,5,11,21,22,23,24,3432,33,3234,341,52,54,56,663]</p>
<p>接着百位数的：</p>
<p><strong>0</strong>           2,4,5,11,21,22,23,24,33,52,54,56,    </p>
<p><strong>1</strong>           </p>
<p><strong>2</strong>           3234,</p>
<p><strong>3</strong>           341,</p>
<p><strong>4</strong>           3432,</p>
<p><strong>5</strong>           </p>
<p><strong>6</strong>           663,</p>
<p><strong>7</strong></p>
<p><strong>8</strong></p>
<p><strong>9</strong></p>
<p>排完百位数之后，数组变为：[2,4,5,11,21,22,23,24,33,52,54,56,3234,341,3432,663]</p>
<p>接着千位数的：</p>
<p><strong>0</strong>           2,4,5,11,21,22,23,24,33,52,54,56,341,663    </p>
<p><strong>1</strong>           </p>
<p><strong>2</strong>           </p>
<p><strong>3</strong>           3234,3432</p>
<p><strong>4</strong>           </p>
<p><strong>5</strong>           </p>
<p><strong>6</strong>           </p>
<p><strong>7</strong></p>
<p><strong>8</strong></p>
<p><strong>9</strong></p>
<p>得到结果：[2,4,5,11,21,22,23,24,33,52,54,56,341,663,3234,3432]</p>
<p>基数排序一看，就跟其他排序不一样，它属于“分配式”排序，根据数组元素数值上的部分信息在当前阶段分配到有序的桶里，再通过不同阶段的分配后使数组有序。</p>
<p>让我们分析一下它的时间复杂度，假设有n个元素，那么每个阶段分配到桶里时间就是n。那究竟跑了多少趟？这个显然与数组中的最大数值的位数有关。假设为k，那么就是k<em>n。当然还有一个时间是收集时间，从桶里面把元素拿出来再组成一个一维数组，这个又与桶的数量有关，假设桶的数量为d,那么就是k</em>d。所以时间复杂度为：O(k*(n+d))。</p>
<p>哎哟，这么一看，这基排还挺不错的，貌似比之前的都要强啊。但是基排也有缺点，就是空间开销比较大，你看它申请的这个桶数组还是二次元的，不是一维的，除此之外还有一个额外的数组用来收集。空间复杂度为O(kd+n)。</p>
<p>直接上程序吧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(lists,radix=<span class="number">2</span>)</span>:</span></div><div class="line">    bits=int(math.ceil(math.log(max(lists),radix)))</div><div class="line">    bucket=[[]<span class="keyword">for</span> i <span class="keyword">in</span> range(radix)]</div><div class="line">    index=<span class="number">0</span></div><div class="line">    <span class="keyword">while</span> index&lt;bits:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> lists:</div><div class="line">            bucket[i&gt;&gt;index&amp;<span class="number">0x1</span>].append(i)</div><div class="line">        <span class="keyword">del</span> lists[:]</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> bucket:</div><div class="line">            lists+=j</div><div class="line">            <span class="keyword">del</span> j[:]</div><div class="line">        index+=<span class="number">1</span></div><div class="line">    <span class="keyword">return</span> lists</div></pre></td></tr></table></figure>
<p>后来我分析了一下，我这个基排为什么会快一些，是因为我只分配了两个桶，即0和1，我把所有数都当做二进制数，这本来也是计算机喜欢的处理方式。然后按照移位处理，便可获取到位数上的值（0或1）进行对号入座。</p>
<h1 id="PK"><a href="#PK" class="headerlink" title="PK"></a>PK</h1><p>写了这么些排序函数，还是来PK一下吧：</p>
<p>无序数组（随机，长度50）：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/sort_pk_50.png" alt="sort_pk" title="">
                </div>
                <div class="image-caption">sort_pk</div>
            </figure></p>
<p>无序数组（随机，长度200）：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/sort_pk_200.png" alt="sort_pk" title="">
                </div>
                <div class="image-caption">sort_pk</div>
            </figure></p>
<p>无序数组（随机，长度1000）：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/sort_pk_1000.png" alt="sort_pk" title="">
                </div>
                <div class="image-caption">sort_pk</div>
            </figure></p>
<p>无序数组（随机，长度5000）：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/sort_pk_5000.png" alt="sort_pk" title="">
                </div>
                <div class="image-caption">sort_pk</div>
            </figure></p>
<p>当然单位都是秒，可以看到，数组数量都还很少的时候，大家都差不多；当数量变大的时候，可以看到快排和基排都是最快的两个（我承认在此例中，基排简直逆天）；到最后，长度达到5000，我想你明白了O(n²)和O(nlogn)的差距了=。=</p>

        <a href="/2017/06/13/八大排序算法（python实现）/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </div>
    
</article>

        </li>
    
    </ul>

    
<nav id="page-nav">
    <div class="inner">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
    </div>
</nav>


</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>SakuraWood(Lee Sure) &copy; 2017</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://sakurawood.github.io/&title=SakuraWood's blogs&pic=http://sakurawood.github.io/img/sakurawood.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://sakurawood.github.io/&title=SakuraWood's blogs&source=sharing IT tech & skills , include Android and Front-end" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://sakurawood.github.io/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=SakuraWood's blogs&url=http://sakurawood.github.io/&via=http://sakurawood.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://sakurawood.github.io/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://sakurawood.github.io/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'waiting for you...';
            clearTimeout(titleTime);
        } else {
            document.title = 'welcome back!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
